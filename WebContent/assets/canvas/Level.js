// -- user code here --
/* --- start generated code --- */

// Generated by  1.5.0 (Phaser v2.6.2)


/**
 * Level.
 */
function Level() {
	
	Phaser.State.call(this);
	
}

/** @type Phaser.State */
var Level_proto = Object.create(Phaser.State.prototype);
Level.prototype = Level_proto;
Level.prototype.constructor = Level;

Level.prototype.init = function () {
	
	this.scale.scaleMode = Phaser.ScaleManager.SHOW_ALL;
	this.scale.pageAlignHorizontally = true;
	this.scale.pageAlignVertically = true;
	this.stage.backgroundColor = '#ffffff';
	
	
	this.Init();
	
};

Level.prototype.preload = function () {
	
	//this.load.pack('section', 'assets/pack.json');
	
};

Level.prototype.create = function () {
	var __MainMenuScene = this.add.group();
	
	var __grpMap = new mapPrefab(this.game, __MainMenuScene);
	__grpMap.position.setTo(-2521.0, 1632.0);
	
	var __GameplayScene = this.add.group();
	
	var _Cloud = this.add.group(__GameplayScene);
	
	var _Cloud1 = this.add.sprite(-2730.0, 547.0, 'EnvironmentAtlas', 'Cloud01', _Cloud);
	_Cloud1.alpha = 0.35;
	_Cloud1.anchor.setTo(0.5, 0.5);
	
	var _Cloud2 = this.add.sprite(-254.0, 41.0, 'EnvironmentAtlas', 'Cloud02', _Cloud);
	_Cloud2.alpha = 0.35;
	_Cloud2.anchor.setTo(0.5, 0.0);
	
	var _Cloud3 = this.add.sprite(-1329.0, -44.0, 'EnvironmentAtlas', 'Cloud03', _Cloud);
	_Cloud3.alpha = 0.35;
	_Cloud3.anchor.setTo(0.5, 0.0);
	
	var _Cloud4 = this.add.sprite(-1770.0, 597.0, 'EnvironmentAtlas', 'Cloud03', _Cloud);
	_Cloud4.alpha = 0.35;
	_Cloud4.anchor.setTo(0.5, 0.5);
	
	var _Cloud5 = this.add.sprite(-663.0, 408.0, 'EnvironmentAtlas', 'Cloud01', _Cloud);
	_Cloud5.alpha = 0.35;
	_Cloud5.anchor.setTo(0.5, 0.5);
	
	var _Cloud6 = this.add.sprite(-2282.0, 137.0, 'EnvironmentAtlas', 'Cloud02', _Cloud);
	_Cloud6.alpha = 0.35;
	_Cloud6.anchor.setTo(0.5, 0.5);
	
	var _Other_player_Shoot = this.add.group(__GameplayScene);
	_Other_player_Shoot.position.setTo(-481.0, 201.0);
	
	var _Other_player_left_shoot = this.add.sprite(-63.0, 73.0, 'characterAtlas', 'player_left_shoot', _Other_player_Shoot);
	_Other_player_left_shoot.scale.setTo(-1.0, 1.0);
	_Other_player_left_shoot.anchor.setTo(0.0, 0.5);
	
	var _player_shoot1 = this.add.sprite(-44.0, 60.0, 'characterAtlas', 'player_shoot', _Other_player_Shoot);
	_player_shoot1.scale.setTo(-1.0, 1.0);
	_player_shoot1.anchor.setTo(0.5, 0.5);
	
	var _Other_player_bow = this.add.sprite(-37.0, 69.0, 'characterAtlas', 'player_bow', _Other_player_Shoot);
	_Other_player_bow.scale.setTo(-1.0, 1.0);
	_Other_player_bow.anchor.setTo(0.0, 0.5);
	
	var _Arrow_sheet1 = this.add.sprite(999.0, 999.0, 'characterAtlas', 'Arrow_01', _Other_player_Shoot);
	_Arrow_sheet1.scale.setTo(-0.2, 0.3);
	_Arrow_sheet1.animations.add('hit', ['Arrow_02'], 60, false);
	_Arrow_sheet1.animations.add('full', ['Arrow_01'], 60, false);
	
	var _player_rigt_shoot1 = this.add.sprite(-31.0, 68.0, 'characterAtlas', 'player_rigt_shoot', _Other_player_Shoot);
	_player_rigt_shoot1.scale.setTo(-1.0, 1.0);
	_player_rigt_shoot1.anchor.setTo(0.5, 0.5);
	
	var _enemy_idle = this.add.sprite(-433.0, 345.0, 'characterAtlas', 'enemy_idle', __GameplayScene);
	
	var _other_player_idle = this.add.sprite(-558.0, 690.0, 'characterAtlas', 'player_idle', __GameplayScene);
	_other_player_idle.scale.setTo(-1.0, 1.0);
	
	var _line = this.add.sprite(271.0, 67.0, 'HUDAtlas', 'tutorialline-sheet0', __GameplayScene);
	_line.scale.setTo(0.0, 0.2);
	
	var _enemy_Shoot = this.add.group(__GameplayScene);
	_enemy_Shoot.position.setTo(-226.0, 77.0);
	
	var _enemy_left_shoot = this.add.sprite(26.0, 62.0, 'characterAtlas', 'enemy_right_shoot', _enemy_Shoot);
	_enemy_left_shoot.anchor.setTo(1.0, 0.5);
	
	this.add.sprite(0.0, 0.0, 'characterAtlas', 'enemy_shoot', _enemy_Shoot);
	
	var _enemy_bow = this.add.sprite(42.0, 62.0, 'characterAtlas', 'enemy_bow', _enemy_Shoot);
	_enemy_bow.anchor.setTo(1.0, 0.5);
	
	var _Enemy_Arrow_sheet = this.add.sprite(1303.0, 1177.0, 'characterAtlas', 'Arrow_01', _enemy_Shoot);
	_Enemy_Arrow_sheet.scale.setTo(-0.2, 0.3);
	_Enemy_Arrow_sheet.anchor.setTo(0.0, 0.5);
	_Enemy_Arrow_sheet.animations.add('hit', ['Arrow_02'], 60, false);
	_Enemy_Arrow_sheet.animations.add('full', ['Arrow_01'], 60, false);
	
	this.add.sprite(40.0, 58.0, 'characterAtlas', 'enemy_left_shoot', _enemy_Shoot);
	
	var _Player = this.add.group(__GameplayScene);
	
	var _Player_Shoot = this.add.group(_Player);
	_Player_Shoot.position.setTo(-588.0, 90.0);
	
	var _player_left_shoot = this.add.sprite(58.0, 72.0, 'characterAtlas', 'player_left_shoot', _Player_Shoot);
	_player_left_shoot.anchor.setTo(0.0, 0.5);
	
	this.add.sprite(0.0, 0.0, 'characterAtlas', 'player_shoot', _Player_Shoot);
	
	var _player_bow = this.add.sprite(33.0, 69.0, 'characterAtlas', 'player_bow', _Player_Shoot);
	_player_bow.anchor.setTo(0.0, 0.5);
	
	var _Arrow_sheet = this.add.sprite(445.0, 1368.0, 'characterAtlas', 'Arrow_01', _Player_Shoot);
	_Arrow_sheet.scale.setTo(0.2, 0.3);
	_Arrow_sheet.animations.add('hit', ['Arrow_02'], 60, false);
	_Arrow_sheet.animations.add('full', ['Arrow_01'], 60, false);
	
	this.add.sprite(18.0, 60.0, 'characterAtlas', 'player_rigt_shoot', _Player_Shoot);
	
	var _Player_Head_Collider = this.add.sprite(-79.0, 62.0, 'characterAtlas', 'Head_Collider', _Player);
	_Player_Head_Collider.alpha = 0.0;
	
	var _Player_Body_Collider = this.add.sprite(-97.0, 85.0, 'characterAtlas', 'Body_Collider', _Player);
	_Player_Body_Collider.alpha = 0.0;
	
	var _player_head_Shoot = this.add.sprite(-240.0, 527.0, 'HUDAtlas', 'head_Shot', _Player);
	_player_head_Shoot.anchor.setTo(0.5, 0.5);
	
	var _player_health = this.add.sprite(-407.0, 123.0, 'HUDAtlas', 'ground_health_full', _Player);
	_player_health.scale.setTo(0.3, 0.3);
	_player_health.animations.add('half', ['ground_health_half'], 60, false);
	_player_health.animations.add('death', ['ground_health_death'], 60, false);
	_player_health.animations.add('full', ['ground_health_full'], 60, false);
	
	var _player_idle = this.add.sprite(-587.0, 271.0, 'characterAtlas', 'player_idle', _Player);
	
	var _Characters = this.add.group(__GameplayScene);
	
	var __grp_characterSkin = new CharacterSkin(this.game, _Characters);
	
	var _input_Point_End = this.add.sprite(-433.0, 549.0, 'HUDAtlas', 'input_Point', __GameplayScene);
	_input_Point_End.anchor.setTo(0.5, 0.5);
	
	var _input_Point_Start = this.add.sprite(-433.0, 650.0, 'HUDAtlas', 'input_Point', __GameplayScene);
	_input_Point_Start.anchor.setTo(0.5, 0.5);
	
	var _dot = this.add.text(130.0, 13.0, ':', {"font":"bold 25px Arial","fill":"#ffffff"}, __GameplayScene);
	
	var _enemy_health = this.add.sprite(-258.0, 212.0, 'HUDAtlas', 'ground_health_full', __GameplayScene);
	_enemy_health.scale.setTo(0.3, 0.3);
	_enemy_health.animations.add('half', ['ground_health_half'], 60, false);
	_enemy_health.animations.add('death', ['ground_health_death'], 60, false);
	_enemy_health.animations.add('full', ['ground_health_full'], 60, false);
	
	var _enemy_Head_Collider = this.add.sprite(7.0, 1.0, 'characterAtlas', 'Head_Collider', __GameplayScene);
	_enemy_Head_Collider.alpha = 0.0;
	
	var _enemy_Body_Collider = this.add.sprite(9.0, 49.0, 'characterAtlas', 'Body_Collider', __GameplayScene);
	_enemy_Body_Collider.alpha = 0.0;
	
	var _enemy_head_Shot = this.add.sprite(-243.0, 98.0, 'HUDAtlas', 'head_Shot', __GameplayScene);
	_enemy_head_Shot.anchor.setTo(0.5, 0.5);
	
	var _Wall_1 = this.add.sprite(1006.0, 774.0, 'characterAtlas', 'Wall', __GameplayScene);
	_Wall_1.scale.setTo(0.5, 0.5);
	_Wall_1.anchor.setTo(0.5, 0.5);
	
	var _Wall_4 = this.add.sprite(981.0, 998.0, 'characterAtlas', 'Wall', __GameplayScene);
	_Wall_4.scale.setTo(0.5, 0.15);
	_Wall_4.anchor.setTo(0.5, 0.5);
	
	var _Wall_2 = this.add.sprite(981.0, 998.0, 'characterAtlas', 'Wall', __GameplayScene);
	_Wall_2.scale.setTo(0.5, 0.15);
	_Wall_2.anchor.setTo(0.5, 0.5);
	
	var _Wall_3 = this.add.sprite(981.0, 998.0, 'characterAtlas', 'Wall', __GameplayScene);
	_Wall_3.scale.setTo(0.5, 0.15);
	_Wall_3.anchor.setTo(0.5, 0.5);
	
	var __grp_Tutorial = new tutorialPrefab(this.game, __GameplayScene);
	__grp_Tutorial.position.setTo(3.0, 51.0);
	
	var _Point_Player = this.add.sprite(90.0, 693.0, 'characterAtlas', 'Body_Collider', __GameplayScene);
	_Point_Player.scale.setTo(1.0, 0.3);
	_Point_Player.alpha = 0.0;
	_Point_Player.anchor.setTo(0.5, 0.5);
	
	var _Point_Enemy = this.add.sprite(512.0, 627.0, 'characterAtlas', 'Body_Collider', __GameplayScene);
	_Point_Enemy.scale.setTo(1.0, 0.3);
	_Point_Enemy.alpha = 0.0;
	_Point_Enemy.anchor.setTo(0.5, 0.5);
	
	var _Point_Player_Bottom = this.add.sprite(-1170.0, 1010.0, 'characterAtlas', 'Body_Collider', __GameplayScene);
	_Point_Player_Bottom.scale.setTo(1.0, 0.3);
	_Point_Player_Bottom.alpha = 0.0;
	_Point_Player_Bottom.anchor.setTo(0.5, 0.5);
	
	var _Point_Player_Top = this.add.sprite(-1170.0, 1010.0, 'characterAtlas', 'Body_Collider', __GameplayScene);
	_Point_Player_Top.scale.setTo(1.0, 0.3);
	_Point_Player_Top.alpha = 0.0;
	_Point_Player_Top.anchor.setTo(0.5, 0.5);
	
	var _txt_player_01 = this.add.text(-840.0, 173.0, 'Player 1', {"font":"bold 25px Arial","fill":"#3684ff"}, __GameplayScene);
	_txt_player_01.anchor.setTo(0.5, 0.0);
	
	var _txt_player_02 = this.add.text(-791.0, 110.0, 'Player 2', {"font":"bold 25px Arial","fill":"#ff2403"}, __GameplayScene);
	_txt_player_02.anchor.setTo(0.5, 0.0);
	
	var __grp_PauseMenu = new pauseMenuPrefab(this.game);
	__grp_PauseMenu.position.setTo(5051.0, -35.0);
	
	var __grpTimeDuel = new timeDuelPrefab(this.game);
	__grpTimeDuel.position.setTo(-1313.0, 1152.0);
	
	var __grpInforPrefab = new inforPrefab(this.game);
	__grpInforPrefab.position.setTo(1907.0, -669.0);
	
	var __grpWorldMapScene = new worldMapPrefab(this.game);
	__grpWorldMapScene.position.setTo(2012.0, 142.0);
	
	var __grpLeaderBoardPrefab = new leaderBoardPrefab(this.game);
	__grpLeaderBoardPrefab.position.setTo(-180.0, 1833.0);
	
	var __grpMapDuel = new mapDuelPrefab(this.game);
	__grpMapDuel.position.setTo(-1222.0, 1676.0);
	
	var __grpMainMenuPrefab = new mainMenuPrefab(this.game);
	__grpMainMenuPrefab.position.setTo(-4487.0, -551.0);
	
	var __grpResultDuelMode = new resultDuel(this.game);
	__grpResultDuelMode.position.setTo(820.0, -1332.0);
	
	var __grp_GameOver = new gameOverPrefab(this.game);
	__grp_GameOver.position.setTo(0.0, -1293.0);
	
	var __grp_Terms = new TermsPrefab(this.game);
	__grp_Terms.position.setTo(4208.0, 151.0);
	
	var __grp_buyNotification = new buyNotificationPrefab(this.game);
	__grp_buyNotification.position.setTo(3197.0, 3364.0);
	
	var __grp_IAP = new IAPPrefab(this.game);
	__grp_IAP.position.setTo(-1910.0, -557.0);
	
	var __grp_SelectStagePrefab = new selectStagePrefab(this.game);
	__grp_SelectStagePrefab.position.setTo(9378.0, -3569.0);
	
	
	
	// public fields
	
	this.f_grpMap = __grpMap;
	this.f_GameplayScene = __GameplayScene;
	this.fCloud1 = _Cloud1;
	this.fCloud2 = _Cloud2;
	this.fCloud3 = _Cloud3;
	this.fCloud4 = _Cloud4;
	this.fCloud5 = _Cloud5;
	this.fCloud6 = _Cloud6;
	this.fOther_player_Shoot = _Other_player_Shoot;
	this.fOther_player_left_shoot = _Other_player_left_shoot;
	this.fOther_player_bow = _Other_player_bow;
	this.fArrow_sheet1 = _Arrow_sheet1;
	this.fEnemy_idle = _enemy_idle;
	this.fOther_player_idle = _other_player_idle;
	this.fLine = _line;
	this.fEnemy_Shoot = _enemy_Shoot;
	this.fEnemy_left_shoot = _enemy_left_shoot;
	this.fEnemy_bow = _enemy_bow;
	this.fEnemy_Arrow_sheet = _Enemy_Arrow_sheet;
	this.fPlayer_Shoot = _Player_Shoot;
	this.fPlayer_left_shoot = _player_left_shoot;
	this.fPlayer_bow = _player_bow;
	this.fArrow_sheet = _Arrow_sheet;
	this.fPlayer_Head_Collider = _Player_Head_Collider;
	this.fPlayer_Body_Collider = _Player_Body_Collider;
	this.fPlayer_head_Shoot = _player_head_Shoot;
	this.fPlayer_health = _player_health;
	this.fPlayer_idle = _player_idle;
	this.f_grp_characterSkin = __grp_characterSkin;
	this.fInput_Point_End = _input_Point_End;
	this.fInput_Point_Start = _input_Point_Start;
	this.fDot = _dot;
	this.fEnemy_health = _enemy_health;
	this.fEnemy_Head_Collider = _enemy_Head_Collider;
	this.fEnemy_Body_Collider = _enemy_Body_Collider;
	this.fEnemy_head_Shot = _enemy_head_Shot;
	this.fWall_1 = _Wall_1;
	this.fWall_4 = _Wall_4;
	this.fWall_2 = _Wall_2;
	this.fWall_3 = _Wall_3;
	this.f_grp_Tutorial = __grp_Tutorial;
	this.fPoint_Player = _Point_Player;
	this.fPoint_Enemy = _Point_Enemy;
	this.fPoint_Player_Bottom = _Point_Player_Bottom;
	this.fPoint_Player_Top = _Point_Player_Top;
	this.fTxt_player_01 = _txt_player_01;
	this.fTxt_player_02 = _txt_player_02;
	this.f_grp_PauseMenu = __grp_PauseMenu;
	this.f_grpTimeDuel = __grpTimeDuel;
	this.f_grpInforPrefab = __grpInforPrefab;
	this.f_grpWorldMapScene = __grpWorldMapScene;
	this.f_grpLeaderBoardPrefab = __grpLeaderBoardPrefab;
	this.f_grpMapDuel = __grpMapDuel;
	this.f_grpMainMenuPrefab = __grpMainMenuPrefab;
	this.f_grpResultDuelMode = __grpResultDuelMode;
	this.f_grp_GameOver = __grp_GameOver;
	this.f_grp_Terms = __grp_Terms;
	this.f_grp_buyNotification = __grp_buyNotification;
	this.f_grp_IAP = __grp_IAP;
	this.f_grp_SelectStagePrefab = __grp_SelectStagePrefab;
	this.Create();
	
};

/* --- end generated code --- */
// -- user code here --
var PLAYMODE = {
    DUEL: 0,
    SINGLE: 1,
    WITHFRIEND: 2,
}
var GAMEMODE = {
    NONE: 0,
    EASY: 1,
    NORMAL: 2,
    HARD: 3,
}
var COLLISION = {
    NONE: 0,
    HEAD: 1,
    BODY: 2,
    GROUND: 3,
    HEATH_BAR: 4,
}

var ENEMYSTATE = {
    NONE: 0,
    IDLE: 1,
    ROTATION_SHOOT: 2,
    SHOOT: 3,
    SETTING_EFFECT_VAR: 4,
    FADE_DEATH: 5, //enemy fade image before death  
    EFFECT_DEATH: 6, //Show effect Death
    RELOAD: 7, //Enemy Reload
    DEATH: 8,
    STAND: 9
};
var enemyState = ENEMYSTATE.NONE;
var SCENES = {
    NONE: 0,
    MAINMENU: 1,
    PLAY: 3,
    SETTING_FADE_PLAYER: 4,
    FADE_PLAYER: 5,
    SHOWEFFECT: 6, // show effect player death before scene game over show
    WAITGAMEOVER: 7, //wait
    GAMEOVER: 8,
    RELOAD: 9,
    WAIT_RELOAD: 10,
};



var STATES = {
    NONE: 0,
    MAINMENU: 1,
    PLAY: 3,
};
var sceneState = STATES.NONE;


var currentScene = SCENES.MAINMENU;
var btn_play;
var btn_play_scale_Change = 1;

var btn_relay;
var btn_menu;
var btn_leaderBoard;

var title_game_sheet;
var gameover_group;




//==Game Over Scene Parameter==
var gameOverInput;

var gameOverSpeedY = 35;
//=============================



//==player parameter==
var player_idle;
var player_shoot;
var player_bow;
var player_left_shoot;
var player_right_shoot;
var player_hand_fingers;
var player_line_bow;
var player_head_Collider;
var player_body_Collider;
var player_current_health;
var player_health_bar;
var player_Death = false;
var player_head_shoot;
var player_Arrow_Group;
var player_sprite_death;
var isPlayerHeadShoot = false;
var player_head_shoot_scale = 0;
var player_head_shoot_alpha = 1;
var player_head_shoot_duration_time = 1.2;
var player_head_shoot_elapsedTime = 0;
var player_arrow_Collider;
var player_number_arrow_shoot = 0;
var playerfade_time = 0;
var player_duration_fade_time = 0.15;
var player_fade_total_time;
var player_arrow_collisions;
//count arrow kill enemy
var player_arrow_count_hit_something = 0;
//=============================




//==enemy parameter==
var enemy_idle;
var enemy_shoot;
var enemy_bow;
var enemy_left_shoot;
var enemy_right_shoot;
var enemy_hand_fingers;
var enemy_line_bow;
var enemy_head_Collider;
var enemy_body_Collider;
var enemy_current_health;
var enemy_health_bar;
var enemy_Death = false;


var enemy_head_Shoot;
var isEnemyHeadShoot = false;
var enemy_head_shoot_scale = 0;
var enemy_head_shoot_alpha = 1;
var enemy_head_shoot_duration_time = 1.2;
var enemy_head_shoot_elapsedTime = 0;
var enemy_fade_time = 0;
var enemy_duration_fade_time = 0.15;
var enemy_fade_total_time;
var enemy_reload_time;
var enemy_reload_show_time = 1.5;
var enemy_elapsed_idle_time;
var enemy_idle_time = 1.3;
var enemy_angle = 0;
var enemy_angle_change = 1;
var enemy_rotation_speed = 0.015;
var enemy_elapsed_shoot = 0;
var enemy_arrow_speed = 0;
var enemy_down_rnd_rotation = 0;
var enemy_arrow_min_speed = 400;
var enemy_arrow_max_speed = 1100;
var enemy_sprite_death;
var enemy_arrow_collisions;
//=============================



//==Score parameter==
var txt_score;
var txt_score_gameOver;
var txt_bestScore_gameOver;
var score = 0;
var bestScore = 0;
var efficiency = 0;
var temp_efficiency = 0;
var bestEfficiency = 0;
var headShot = 0;
var bestHeadShot = 0; //best Head Shot
var effeiciency_number_arrow_update = 5; //when arrow_Shoot>number_arrow update efficiency
//=============================

//==Tutorial parameter==
var tutorial_hand;
var tutorial_scene;
var tutorial_circle;
var tutorial_Line;
var tween_tutorial_hand;
var isTutorial = false;
var isFirstTime = false; //First Play Game
var lineTutorial;
//=============================



//=======arrow parameter======
var arrowObject;
var arrowEnemyObject;
var arrowPlayer;
var arrowPlayerPool;
var arrowPlayerVisible;
var arrowPlayerElapsedTime;
var arrowPlayerDuration = 4.5;
var arrowPlayerCurrentIndex;
var arrowPlayerHeadShoot;
var arrowsPlayerBody = new Array();
var arrowPlayerBodyIndex = 0;
var arrowEnemy;
var arrowEnemyPool;
var arrowEnemyVisible;
var arrowEnemyElapsedTime;
var arrowEnemyDuration = 4.5;
var arrowEnemyCurrentIndex = 0;



var isShoot = false;
var arrowSpeed; //distance of start line and end line
//=============================

var wallGroup;
var wall_current_level = 1;
var wall_change = 1;
var difficult_raise_time = 0;
var isUpdateDifficult = false;

var sceneGame;
var backGround;
var playMode = PLAYMODE.SINGLE;


var isInit = false;
var isMouseDrag; //when mouse drag in scene
var game;
var spaceInput;
var index = 0;
var line;
var gameMode = GAMEMODE.EASY; //game Mode of game

var deathCount = 0;
var isShowAds = false;
var level;
// ============ CONSTANT==============
var OUT_SIDE_POSITION = 9999;
var GRAVITY = 225; // pixels/second/second
var ARROW_ACCEL = 2.5;
var MAX_HEALTH = 2;
var MAX_ROTATION = 1.5;
var LIMIT_BOTTOM_GAMEOVER_GROUP = 1300;
var LIMIT_SPEED_ARROW = 50;
var PLAYER_POSITION_X_STAND = 70;
var ENEMY_POSITION_X_STAND = 570;
var POSITION_Y_MIN = 7.8; //7.8
var POSITION_Y_MAX = 1.5; //1.5
var SCREEN_WIDTH;
var SCREEN_HEIGHT;
var CHARACTER_DROP_SPEED = 10;
var NUMBER_OF_ARROWS = 20;
var WALL_SPEED = 1;
var LEVEL_MAX = 4;
var LEVEL_TIME = 45; //difficult of game will raise
var WALL_LIMIT_BOTTOM = 810;
var WALL_LIMIT_TOP = 300;
var MAX_ARROW_UPDATE_EFFICIENCY = 5;
var FADE_EFFECT_CHARACTER_COUNT = 2;
var DEATH_NUMBER_SHOW_ADS = 3;
var SCORE_RAISE_DIFFICULT = 10;

var line1, line2, line3, line4;

var X_POSITION_ADD_MULTIPLAYER = 75;




Level.prototype.update = function() {
    
   
    
    
	if(this.f_grpMapDuel.isStartTime){
		this.f_grpMapDuel.updateWaitTimeJoinRoom();
    }
  
    if( this.pauseGame()) return;
    
    if (game.sound.usingWebAudio && game.sound.context.state === 'suspended') {
        game.sound.context.resume();
       }

    this.f_grpWorldMapScene.manualUpdate();

	this.f_grpMapDuel.manualUpdate();

    this.f_grpResultDuelMode.manualUpdate();
    

    if (this.playMode === PLAYMODE.SINGLE){
        enemy_idle = this.fEnemy_idle;
        enemy_shoot = this.fEnemy_Shoot;
        enemy_bow = this.fEnemy_bow;
        enemy_left_shoot = this.fEnemy_left_shoot;
    }
   // console.log("Before");
    if (!this.isPlayGame) return;
 


 
    if (this.playMode != PLAYMODE.SINGLE) {

        if (this.f_grpTimeDuel.IsStartTime) {
            this.updateTimeDuelMode();
        }
        if (this.f_grpTimeDuel.isEndTime) {
            return;
        }
    }
   
  


    //Reload Position
    if (userType === USERTYPE.MASTER && !this.isPositionGenerated && player_current_health > 0 && enemy_current_health > 0) {
        this.enemy_next_Point_X = ENEMY_POSITION_X_STAND + X_POSITION_ADD_MULTIPLAYER;
        this.enemy_next_Point_Y = RndPosition(gameHeight() / POSITION_Y_MIN + enemy_idle.height, gameHeight() / POSITION_Y_MAX - enemy_idle.height);
        this.player_next_Point_X = PLAYER_POSITION_X_STAND;
        this.player_next_Point_Y = RndPosition(gameHeight() / POSITION_Y_MIN + player_idle.height, gameHeight() / POSITION_Y_MAX - player_idle.height);

        this.isPositionGenerated = true;
    }




    message = "";
    message = ' "position" : ' +
        '{ "playerX":"' + player_idle.x + '" , "playerY":"' + player_idle.y + '", ' +
        ' "enemyX":"' + enemy_idle.x + '" , "enemyY":"' + enemy_idle.y +
        '", "nextPointX":"' + this.other_next_Point_X + '", "nextPointY":"' + this.other_next_Point_Y +
        '", "pointX":"' + this.player_next_Point_X + '", "pointY":"' + this.player_next_Point_Y + '"},';

    if (currentScene === SCENES.PLAY) {
        isTutorial = !isFirstTime;
        //When Game play show ads false
        isShowAds = false;

        
        if (!this.isShootArrow) {

            this.OnMouseDown();
            //this.f_Oliver.OnMouseDown();
            this.OnMouseDrag();
            this.OnMouseUp();


        }


        this.f_grpTimeDuel.updateTime();

        //Register Collision
        registerCollision();

        this.settingCharacter();
        
        if(this.playMode === PLAYMODE.SINGLE) this.healthBarPosition();
        
        

        //Caculator arrow Speed follow distance of input start and end

        if (userType === USERTYPE.MASTER) {
            var angle = this.game.physics.arcade.angleBetween(this.inputPointEnd, this.inputPointStart);
            arrowSpeed = Phaser.Math.distance(this.inputPointStart.x, this.inputPointStart.y, this.inputPointEnd.x, this.inputPointEnd.y);
            line.rotation = angle;
            if (angle >= 1.6) angle = 1.6;
            if (angle <= -1.6) angle = -1.6;
            player_bow.rotation = angle;
            player_line_bow.rotation = angle  ;
            player_left_shoot.rotation = angle *1.25 ;
            player_right_shoot.rotation = angle/6.5 ;
            player_hand_fingers.rotation = angle *1.1 ;
            //Send message Rotation to other player;
  

            message += ' "rotation" : ' +
            '{ "bowRotation":"' + player_bow.rotation + '" , "leftShootRotation":"' + player_left_shoot.rotation + ' ", "rightShootRotation":"' + player_right_shoot.rotation 
            + ' ", "handFingers":"' + player_hand_fingers.rotation + ' ", "lineBow":"' + player_line_bow.rotation + ' "}, ';


            var scaleLine = game.math.distance(this.inputPointStart.x, this.inputPointStart.y, this.inputPointEnd.x, this.inputPointEnd.y).toFixed(2) / 240;
            line.scale.setTo(-scaleLine, 0.2);
            line.x = inputPointStart.x - 5;
            line.y = inputPointStart.y;
        } else {
            angle = this.game.physics.arcade.angleBetween(this.inputPointStart, this.inputPointEnd);
            arrowSpeed = Phaser.Math.distance(this.inputPointStart.x, this.inputPointStart.y, this.inputPointEnd.x, this.inputPointEnd.y);
            line.rotation = angle;
            if (angle >= 1.6) angle = 1.6;
            if (angle <= -1.6) angle = -1.6;
            enemy_bow.rotation = -angle;
            enemy_left_shoot.rotation = -angle * 1.25;

            var rightShoot = 0;
            var handFingers = 0;
            var lineBow = 0;

            if(enemy_right_shoot!=undefined){
                enemy_right_shoot.rotation = -angle/6.5;
                enemy_hand_fingers.rotation = -angle *1.1;
                enemy_line_bow.rotation = -angle;
                rightShoot = enemy_right_shoot.rotation;
                handFingers = enemy_hand_fingers.rotation;
                lineBow = enemy_line_bow.rotation;
            }

  
            message += ' "rotation" : ' +
            '{ "bowRotation":"' + enemy_bow.rotation + '" , "leftShootRotation":"' + enemy_left_shoot.rotation + ' ", "rightShootRotation":"' + enemy_right_shoot.rotation 
            + ' ", "handFingers":"' + enemy_hand_fingers.rotation + ' ", "lineBow":"' + enemy_line_bow.rotation + ' "}, ';


            var scaleLine = game.math.distance(this.inputPointEnd.x, this.inputPointEnd.y, this.inputPointStart.x, this.inputPointStart.y).toFixed(2) / 240;

            line.scale.setTo(scaleLine, 0.2);
            line.x = this.inputPointStart.x;
            line.y = this.inputPointStart.y;
        }

        if (userType === USERTYPE.MASTER) {

            if (arrowPlayer != null || arrowPlayer != undefined) {

                if (isShoot) {
                    arrowPlayer.rotation = angle;
                    message += ' "arrowRotation" : ' +
                        '{ "rotation":"' + arrowPlayer.rotation + '"}, ';
                } else {

                    if (Math.abs(arrowPlayer.x) >= SCREEN_WIDTH + arrowPlayer.width ||
                        ((arrowPlayer.y >= SCREEN_HEIGHT + arrowPlayer.height ||
                            arrowPlayer.y <= 0 - arrowPlayer.height))) {
                    	this.isShootArrow = arrowPlayer.visible;

                    }
                    // Rotate all living bullets to match their trajectory
                    arrowPlayerPool.forEachAlive(function(arrow) {
                        arrow.rotation = Math.atan2(arrow.body.velocity.y, arrow.body.velocity.x);
                    }, this);
                }
            }
        } else {



            if (arrowEnemy != null || arrowEnemy != undefined) {

                if (isShoot) {
                    arrowEnemy.rotation = angle;
                    message += ' "arrowRotation" : ' +
                        '{ "rotation":"' + arrowEnemy.rotation + '"}, ';
                } else {


                    //KIll arrow when arrow out bounds
                    if (Math.abs(arrowEnemy.x) <= 0 - arrowEnemy.width ||
                        ((arrowEnemy.y >= SCREEN_HEIGHT + arrowEnemy.height ||
                            arrowEnemy.y <= 0 - arrowEnemy.height))) {
                    	this.isShootArrow = arrowEnemy.visible;

                    }
                    // Rotate all living bullets to match their trajectory
                    arrowEnemyPool.forEachAlive(function(arrow) {
                        if(GlobalSetting.pauseGame) return;
                        arrow.rotation = Math.atan2(-arrow.body.velocity.y, -arrow.body.velocity.x);
                    }, this);
                }

            }
        }

        if (userType === USERTYPE.MASTER) {
            var currentOtherPlayerHealth = enemy_current_health;
            var currentPlayerHealth = player_current_health;

        } else {
            currentOtherPlayerHealth = player_current_health;
            currentPlayerHealth = enemy_current_health;
        }
        //console.log("arrowSpeed " +arrowSpeed);


        if (arrowSpeed != 0) {
            this.other_arrow_Speed = arrowSpeed;
            this.other_arrow_Speed;
            this.other_elapsedTime_reset_speed = game.time.totalElapsedSeconds() + this.other_time_reset_speed
        } else {
            if (game.time.totalElapsedSeconds() >= this.other_elapsedTime_reset_speed) {
                this.other_arrow_Speed = 0;
            }
        }

        message += ' "shoot" : ' +
            '{ "isShoot":"' + isShoot + '" , "arrowSpeed":"' + this.other_arrow_Speed + '", "isShootArrow":"' + this.isShootArrow +
            '", "isMouseDrag":"' + isMouseDrag + '","pointerDown":"' + this.game.input.activePointer.isDown +
            '","pointerUp":"' + this.game.input.activePointer.isUp + '"}, ';


        

        

        message += ' "reload" : ' +
            '{ "position":"false"}, ';
        message += ' "death" : ' +
            '{ "death":"false"}, ';


        message += ' "health" : ' +
            '{ "current":"' + currentOtherPlayerHealth + '","other":"' + currentPlayerHealth + '" } ';

        this.sendMessage(message);
    } else if (currentScene === SCENES.SETTING_FADE_PLAYER) {
    	this.Time.stop();
        //send msg
        message += ' "reload" : ' +
            '{ "position":"404"}, ';

        message += ' "death" : ' +
            '{ "death":"true"} ';

        this.sendMessage(message);


        if (this.playMode != PLAYMODE.SINGLE) {
            if (arrowPlayer != null || arrowPlayer != undefined) {
                arrowPlayer.position.setTo(OUT_SIDE_POSITION, OUT_SIDE_POSITION);
                arrowPlayer.visible = false;
            }

            if (arrowEnemy != null || arrowEnemy != undefined) {
                arrowEnemy.position.setTo(OUT_SIDE_POSITION, OUT_SIDE_POSITION);
                arrowEnemy.visible = false;
            }


            this.isPreventClickWhenDeath = true;
        }

        player_fade_time = game.time.totalElapsedSeconds() + player_duration_fade_time;
        player_fade_total_time = game.time.totalElapsedSeconds() + (player_duration_fade_time * FADE_EFFECT_CHARACTER_COUNT);
        currentScene = SCENES.FADE_PLAYER;
        inputPointStart.position.setTo(OUT_SIDE_POSITION, OUT_SIDE_POSITION);
        inputPointEnd.position.setTo(OUT_SIDE_POSITION, OUT_SIDE_POSITION);
        line.x = inputPointStart.x - 5;
        line.y = inputPointStart.y;
      //  this.isShootArrow = true;



    } else if (currentScene === SCENES.FADE_PLAYER) {
        //send msg



        if (game.time.totalElapsedSeconds() >= player_fade_time) {
            player_sprite_death.visible = !player_sprite_death.visible;
            player_fade_time = game.time.totalElapsedSeconds() + player_duration_fade_time;

        }

        if (game.time.totalElapsedSeconds() >= player_fade_total_time) {

            message += ' "reload" : ' +
                '{ "position":"404"}, ';

            message += ' "death" : ' +
                '{ "death":"false"} ';

            this.sendMessage(message);
            currentScene = SCENES.SHOWEFFECT;
        }
    } else if (currentScene === SCENES.SHOWEFFECT) {




        //console.log("player_sprite_death " +player_sprite_death.y);
        player_sprite_death.visible = true;
        player_sprite_death.y += CHARACTER_DROP_SPEED;
        if (userType === USERTYPE.MASTER)
            this.fTxt_player_01.y += CHARACTER_DROP_SPEED;
        else
            this.fTxt_player_02.y += CHARACTER_DROP_SPEED;
        if (this.playMode != PLAYMODE.SINGLE) {
            for (var i = 0; i < arrowEnemyPool.length; i++) {
                if (enemy_arrow_collisions[i] === COLLISION.BODY ||
                    enemy_arrow_collisions[i] === COLLISION.HEAD) {
                    arrowEnemyPool.getAt(i).y += CHARACTER_DROP_SPEED;
                }
            }

            for (var i = 0; i < arrowPlayerPool.length; i++) {
                if (player_arrow_collisions[i] === COLLISION.BODY ||
                    player_arrow_collisions[i] === COLLISION.HEAD) {
                    arrowPlayerPool.getAt(i).y += CHARACTER_DROP_SPEED;
                }
            }
        } else {
            for (var i = 0; i < arrowEnemyPool.length; i++) {
                if (enemy_arrow_collisions[i] === COLLISION.BODY ||
                    enemy_arrow_collisions[i] === COLLISION.HEAD) {
                    arrowEnemyPool.getAt(i).y += CHARACTER_DROP_SPEED;
                }
            }
        }



        if (player_sprite_death.y >= SCREEN_HEIGHT + 300) {
            if (this.playMode === PLAYMODE.SINGLE) {
                
                elapsedtime_load_video_ADS = this.game.time.totalElapsedSeconds() + this.wait_time_load_video_ADS;

                this.showVideo();
            }

            //Update LeaderBoard
            this.updateLeaderBoard();
            //Save Data
            this.saveData();

            if (this.playMode != PLAYMODE.SINGLE) {
                currentScene = SCENES.RELOAD;
                this.player_elapsedTime_Reload = game.time.totalElapsedSeconds() + this.player_time_Reload;

            } else {
                currentScene = SCENES.GAMEOVER;
            }
            //player_health_bar.visible  = false;
        }




    } else if (currentScene === SCENES.RELOAD) {



        message = ' "position" : ' +
            '{ "playerX":"' + player_idle.x + '" , "playerY":"' + player_idle.y + '", ' +
            ' "enemyX":"' + enemy_idle.x + '" , "enemyY":"' + enemy_idle.y +
            '", "nextPointX":"' + this.other_next_Point_X + '", "nextPointY":"' + this.other_next_Point_Y +
            '", "pointX":"' + this.player_next_Point_X + '", "pointY":"' + this.player_next_Point_Y + '"},';

        message += ' "reload" : ' +
            '{ "position":"true"} ';

        this.sendMessage(message);




        if (game.time.totalElapsedSeconds() >= this.player_elapsedTime_Reload) {
         
            if (userType === USERTYPE.MASTER) {
                //Reload Character
              level.playerReload();
            
            } else {
               level.enemyReload();
           }

            if (this.isPreventClickWhenDeath) {
                this.isPlayerReloadWhenClick = true;
            }

            //Reload
            this.isShootArrow = false;




            if (userType === USERTYPE.MASTER) {

                options = {};
                options.receivers = Photon.LoadBalancing.Constants.ReceiverGroup.All;
                var position = {};
                position.playerX = this.player_next_Point_X;
                position.playerY = this.player_next_Point_Y;
                position.enemyX = this.enemy_next_Point_X;
                position.enemyY = this.enemy_next_Point_Y;
                GlobalSetting.photonManager.onRaiseEvent(4, position, options);
                setTimeout(function() {
                    level.isPositionGenerated = false;
                }, 1000);

            }


            this.isOtherPlayerDeath = false;
            currentScene = SCENES.PLAY;




        }
    } else if (currentScene === SCENES.WAIT_RELOAD) {
        currentScene = SCENES.PLAY;

    } else if (currentScene === SCENES.GAMEOVER) {
   
        //Scene GameOver
        this.f_grp_GameOver.visible = true;
        this.f_grp_PauseMenu.visible = false;
    	//update Result
    	this.f_grp_GameOver.updateEfficiency(efficiency,bestEfficiency);
    	this.f_grp_GameOver.updateHeadShot(headShot,bestHeadShot);
    	this.f_grp_GameOver.updateScore(score,bestScore);
    	this.f_grp_GameOver.caculatorResult(this.elapsedTime_Single_Mode,this.enemy_kill_count);
        this.sceneGameOver();
        currentScene = SCENES.NONE;

    }


    if (this.playMode === PLAYMODE.SINGLE) {
        //STATE ENEMY
        this.stateEnemy();
    }




    if (isEnemyHeadShoot) {

        if (enemy_head_shoot_scale >= 1) {
            enemy_head_Shoot_alpha -= 0.05;
            enemy_head_Shoot.alpha = enemy_head_Shoot_alpha;
            if (game.time.totalElapsedSeconds() >= enemy_head_shoot_elapsedTime) {
                enemy_head_Shoot.visible = false;
                isEnemyHeadShoot = false;
                enemy_head_shoot_scale = 0;
                enemy_head_Shoot.scale.setTo(enemy_head_shoot_scale);
            }
        } else {
            enemy_head_Shoot.alpha = 1;
            enemy_head_Shoot_alpha = 1;
            enemy_head_Shoot.visible = true;
            enemy_head_Shoot.x = enemy_idle.x - 77;
            enemy_head_Shoot.y = enemy_idle.y - 4;
            enemy_head_shoot_scale += (0.1);
            enemy_head_Shoot.scale.setTo(enemy_head_shoot_scale);
            enemy_head_shoot_elapsedTime = game.time.totalElapsedSeconds() + enemy_head_shoot_duration_time;
        }
    }

    if (isPlayerHeadShoot) {

        if (player_head_shoot_scale >= 1) {
            player_head_Shoot_alpha -= 0.05;
            player_head_shoot.alpha = player_head_Shoot_alpha;
            if (game.time.totalElapsedSeconds() >= player_head_shoot_elapsedTime) {
                player_head_shoot.visible = false;
                isPlayerHeadShoot = false;
                player_head_shoot_scale = 0;
                player_head_shoot.scale.setTo(player_head_shoot_scale);
            }
        } else {
            player_head_shoot.alpha = 1;
            player_head_Shoot_alpha = 1;
            player_head_shoot.visible = true;
            player_head_shoot.x = player_idle.x + 151;
            player_head_shoot.y = player_idle.y - 7;
            player_head_shoot_scale += (0.1);
            player_head_shoot.scale.setTo(player_head_shoot_scale);
            player_head_shoot_elapsedTime = game.time.totalElapsedSeconds() + player_head_shoot_duration_time;
        }
    }




    if (isTutorial) {
    	 this.f_grp_Tutorial.manualUpdate();
    
    }

    //Time Hide Arrow when arrow apper ground and enemy 
    for (var i = 0; i < arrowPlayerVisible.length; i++) {
        if (arrowPlayerVisible[i]) {
            if (game.time.totalElapsedSeconds() >= arrowPlayerElapsedTime[i]) {
                arrowPlayerPool.getAt(i).visible = false;
                arrowPlayerVisible[i] = false;
                player_arrow_collisions[i] = COLLISION.NONE;
            }
        }
    }



    for (var i = 0; i < arrowEnemyVisible.length; i++) {
        if (arrowEnemyVisible[i]) {

            if (game.time.totalElapsedSeconds() >= arrowEnemyElapsedTime[i]) {
                arrowEnemyPool.getAt(i).visible = false;
                arrowEnemyVisible[i] = false;
                enemy_arrow_collisions[i] = COLLISION.NONE;
            }
        }
    }



    for (var i = 0; i < arrowPlayerPool.length; i++) {

        var arrow = arrowPlayerPool.getAt(i);
        if (Math.abs(arrow.x) >= SCREEN_WIDTH + arrow.width ||
            ((arrow.y >= SCREEN_HEIGHT + arrow.height ||
                arrow.y <= 0 - arrow.height))) {
            arrow.body.allowGravity = false;

            arrow.kill();
            player_arrow_collisions[i] = COLLISION.NONE;
            //if(userType === USERTYPE.MASTER)
            //this.other_pointer_down = false;

        }
    }

    for (var i = 0; i < arrowEnemyPool.length; i++) {

        var arrow = arrowEnemyPool.getAt(i);
        if (Math.abs(arrow.x) <= 0 - arrow.width ||
            ((arrow.y >= SCREEN_HEIGHT + arrow.height ||
                arrow.y <= 0 - arrow.height))) {
            arrow.body.allowGravity = false;
            arrow.kill();
            enemy_arrow_collisions[i] = COLLISION.NONE;
 
        }
    }


    if (isUpdateDifficult) {
        // this.updateChallengeMode();
        if (this.playMode === PLAYMODE.SINGLE)
            this.wallMovement();
        //Cloud fly
        this.flyCloud();
    }

    //Update efficiency
    this.updateEfficiency();
    //Set Size Collider
    this.setSizeCollider();




    if (this.isMessageHandler) {
        this.messageHandler();
    }




}
Level.prototype.pauseGame = function() {
    if(	GlobalSetting.pauseGame ){
        if( arrowPlayer!=undefined){
            arrowPlayer.body.velocity.x = 0;
            arrowPlayer.body.velocity.y = 0;
        }
        if( arrowEnemy!=undefined){
            arrowEnemy.body.velocity.x  =0;
            arrowEnemy.body.velocity.y  =0;
        }
        
        this.fWall_1.visible  = false;
        return true;
    } 

    if( arrowPlayer!=undefined){
	    this.prevVelocityPlayerX =  arrowPlayer.body.velocity.x;
        this.prevVelocityPlayerY =  arrowPlayer.body.velocity.y;
    }

    if( arrowEnemy!=undefined){
	    this.prevVelocityEnemyX =  arrowEnemy.body.velocity.x;
        this.prevVelocityEnemyY =  arrowEnemy.body.velocity.y;
    }


    
    this.fWall_1.visible  = true;

    return false;
}

Level.prototype.clearAllArrow = function() {
  //  console.log("Clear All Arrow");
    for (var i = 0; i < arrowPlayerPool.length; i++) {

        if (arrowPlayer != undefined || arrowPlayer != null) {
            if (arrowPlayerPool.getAt(i) === arrowPlayer) continue;
        }
        arrowPlayerPool.getAt(i).visible = false;
    }



    for (var i = 0; i < arrowEnemyPool.length; i++) {
        if (arrowEnemy != undefined || arrowEnemy != null) {
            if (arrowEnemyPool.getAt(i) === arrowEnemy) continue;
        }
        arrowEnemyPool.getAt(i).visible = false;
    }
}

//Handler messager send to other player
Level.prototype.messageHandler = function() {
    if (GlobalSetting.photonManager.messageOtherPlayer != undefined) {
        var message = GlobalSetting.photonManager.messageOtherPlayer;

        message = "{" + message + "}";

      //  console.log("Message " +message);

        var obj = JSON.parse(message);
        this.jsonMessage = obj;


        if (obj.position != undefined && obj.reload.position === "false") {


            if (obj.shoot.pointerDown === "true" && obj.shoot.isShootArrow === "false") {
                this.other_shoot_arrow = false;
                if (!this.other_pointer_down) {
                    this.onMouseDownOtherPlayer();
                    this.other_pointer_down = !this.other_pointer_down;
                }

            }
            


            if (userType === USERTYPE.CLIENT) {

                //Check health player 
                if (checkHealth(enemy_health_bar, enemy_current_health) && !this.isPlayerDeath) {

                    if (player_idle.visible) other_player_sprite_death = player_idle;
                    if (player_shoot.visible) other_player_sprite_death = player_shoot;

                    this.isPlayerDeath = !this.isPlayerDeath;
                }

             


                //check health other player
                
                player_current_health = parseInt(obj.health.other);
                if (checkHealth(player_health_bar, player_current_health) && !this.isOtherFadeFirst) {

                   //  this.otherScene = SCENES.SETTING_FADE_PLAYER;
                    this.isOtherFadeFirst = !this.isOtherFadeFirst;
                    if (player_idle.visible) other_player_sprite_death = player_idle;
                    if (player_shoot.visible) other_player_sprite_death = player_shoot;
                }

             
                // console.log("obj.shoot.isMouseDrag " +obj.shoot.isMouseDrag);
                if (obj.shoot.isMouseDrag === "true") {
                    if (arrowPlayer != undefined || arrowPlayer != null) {

                        arrowPlayer.rotation = parseFloat(obj.arrowRotation.rotation);

                    }
                    if( !player_idle.visible ){
                    	 player_shoot.visible = true;
                    }
               
                    player_bow.rotation = parseFloat(obj.rotation.bowRotation);
                    player_left_shoot.rotation = parseFloat(obj.rotation.leftShootRotation);
                    player_right_shoot.rotation = parseFloat(obj.rotation.rightShootRotation);
                    player_hand_fingers.rotation = parseFloat(obj.rotation.handFingers);
                    player_line_bow.rotation = parseFloat(obj.rotation.lineBow);
                }

                if (obj.shoot.pointerUp === "true") {
                    if (!this.other_shoot_arrow) {
                        this.other_shoot_arrow = !this.other_shoot_arrow;
                        this.OnMouseUpOtherPlayer();
                        // console.log("arrowPlayer " +arrowPlayer);
                        if (arrowPlayer != null || arrowPlayer != undefined) {
                            //Shoot Arrow
                            setTimeout(function() {
                                level.other_pointer_down = false;
                            }, 500);
                            shootArrowOther(arrowPlayer, parseFloat(obj.shoot.arrowSpeed), player_bow.rotation);
                        }
                    } else {


                        if (arrowPlayer != null || arrowPlayer != undefined) {
                            // Rotate all living bullets to match their trajectory
                            arrowPlayerPool.forEachAlive(function(arrow) {
                                arrow.rotation = Math.atan2(arrow.body.velocity.y, arrow.body.velocity.x);
                            }, this);
                        }
                    }

                }
              



            } else {

                //player_current_health =  parseInt(obj.health.current);
                if (checkHealth(player_health_bar, player_current_health) && !this.isPlayerDeath) {
                    //console.log("Current Health " + player_current_health);
                    this.isPlayerDeath = !this.isPlayerDeath;
                }
             


                enemy_current_health = parseInt(obj.health.other);
                //if obj.health.current === 0 enemy death
                if (checkHealth(enemy_health_bar, enemy_current_health) && !this.isOtherFadeFirst) {
                    //if obj.health.current === 0 player death
                    if (enemy_idle.visible) other_player_sprite_death = enemy_idle;
                    if (enemy_shoot.visible) other_player_sprite_death = enemy_shoot;

                    //this.otherScene = SCENES.SETTING_FADE_PLAYER;
                    this.isOtherFadeFirst = !this.isOtherFadeFirst;
                }
               
                //console.log("obj.shoot.isMouseDrag " +obj.shoot.isMouseDrag);
                if (obj.shoot.isMouseDrag === "true") {

                    if (arrowEnemy != undefined || arrowEnemy != null) {
                        arrowEnemy.rotation = parseFloat(obj.arrowRotation.rotation);

                    }
                   if(! enemy_idle.visible){
                	   enemy_shoot.visible = true;
                   }
                   
                    enemy_bow.rotation = parseFloat(obj.rotation.bowRotation);

                    enemy_left_shoot.rotation = parseFloat(obj.rotation.leftShootRotation);


                    enemy_right_shoot.rotation = parseFloat(obj.rotation.rightShootRotation);
                    enemy_hand_fingers.rotation = parseFloat(obj.rotation.handFingers);
                    enemy_line_bow.rotation = parseFloat(obj.rotation.lineBow);
                }

                if (obj.shoot.pointerUp === "true") {


                    if (!this.other_shoot_arrow) {

                        this.OnMouseUpOtherPlayer();
                        this.other_shoot_arrow = !this.other_shoot_arrow;
                        if (arrowEnemy != null || arrowEnemy != undefined) {
                            //Shoot ArrowcurrentSettingClient
                            setTimeout(function() {
                                level.other_pointer_down = false;
                            }, 500);
                            shootArrowOther(arrowEnemy, -parseFloat(obj.shoot.arrowSpeed), -enemy_bow.rotation);
                        }
                    } else {


                        if (arrowEnemy != null || arrowEnemy != undefined) {
                            // Rotate all living bullets to match their trajectory
                            arrowEnemyPool.forEachAlive(function(arrow) {
                                arrow.rotation = Math.atan2(-arrow.body.velocity.y, -arrow.body.velocity.x);
                            }, this);
                        }




                    }


                }
              




            }
        }
        
        
        

        if (obj.death != undefined) {
            //check health other player
            if (obj.death.death === "true" && !this.isOtherPlayerDeath) {
                //if obj.health.current === 0 player death
                this.isOtherFadeFirst = false;
                this.otherScene = SCENES.SETTING_FADE_PLAYER;
                if (userType === USERTYPE.MASTER) {
                    if (enemy_idle.visible) other_player_sprite_death = enemy_idle;
                    if (enemy_shoot.visible) other_player_sprite_death = enemy_shoot;
                    checkHealth(enemy_health_bar, 0);
                    if (arrowEnemy != undefined) {
                        // console.log("Hide Arrow");
                        arrowEnemy.visible = false;
                        //arrowEnemy = null;
                    }
                } else {

                    if (player_idle.visible) other_player_sprite_death = player_idle;
                    if (player_shoot.visible) other_player_sprite_death = player_shoot;

                    checkHealth(player_health_bar, 0);
                    //console.log("Hide Arrow");
                    if (arrowPlayer != undefined) {
                        arrowPlayer.visible = false;
                        //arrowPlayer = null;
                    }
                }
                this.isOtherPlayerDeath = true;
            }

        }

        this.otherPlayerDeath();

        
        if (obj.reload != undefined) {
            if (obj.reload.position === "true" && !this.other_reload) {
                this.other_reload = true;
                this.isOtherPlayerDeath = false;
                setTimeout(function() {
                    level.other_reload = false;
                }, 500);

                if (userType === USERTYPE.MASTER && enemy_current_health > 0) {
                    options = {};
                    options.receivers = Photon.LoadBalancing.Constants.ReceiverGroup.All;

                    var position = {};
                    position.playerX = this.player_next_Point_X;
                    position.playerY = this.player_next_Point_Y;
                    position.enemyX = this.enemy_next_Point_X;
                    position.enemyY = this.enemy_next_Point_Y;
                    GlobalSetting.photonManager.onRaiseEvent(4, position, options);
                    setTimeout(function() {
                        level.isPositionGenerated = false;
                    }, 1000);



                }

                this.otherScene = SCENES.NONE;


                if (userType === USERTYPE.CLIENT) {
                    //Active Collider
                    player_head_Collider.body.enable = true;
                    player_body_Collider.body.enable = true;
                    player_idle.visible = true;
                    player_current_health = MAX_HEALTH;
                    player_health_bar.animations.play('full');
                    if (arrowEnemy != undefined) {
                        arrowEnemy.x = enemy_idle.x + this.f_grp_characterSkin.currentSettingClient.position_X_Arrow;
                        arrowEnemy.y = enemy_idle.y + this.f_grp_characterSkin.currentSettingClient.position_Y_Arrow;
                    }
                } else {

                    enemy_current_health = MAX_HEALTH;
                    enemy_health_bar.animations.play('full');
                    enemy_idle.visible = true;

                    if (arrowPlayer != undefined) {
                        arrowPlayer.x = player_idle.x + this.f_grp_characterSkin.currentSettingMaster.position_X_Arrow;
                        arrowPlayer.y = player_idle.y + this.f_grp_characterSkin.currentSettingMaster.position_Y_Arrow;
                    }
                }
            }



        }

    }

}

Level.prototype.showVideo = function(){
    deathCount++;
    if (deathCount >= DEATH_NUMBER_SHOW_ADS) {
        //ShowAds

        FBshowInterstitial();
        deathCount = 0;
    }
}
Level.prototype.resumeVeclocityPlayer = function(){
    if(arrowPlayer === undefined ||arrowPlayer === null ) return;
    arrowPlayer.body.velocity.x = this.prevVelocityPlayerX;
    arrowPlayer.body.velocity.y = this.prevVelocityPlayerY;
}

Level.prototype.resumeVeclocityEnemy = function(){
    if(arrowEnemy === undefined ||arrowEnemy === null ) return;
    arrowEnemy.body.velocity.x = this.prevVelocityEnemyX;
    arrowEnemy.body.velocity.y = this.prevVelocityEnemyY;
}


Level.prototype.endWhenActorLeftRoom = function() {
    if(this.f_grpResultDuelMode.endBattle) return;
    
    this.f_grpResultDuelMode.visible = true;
    this.f_grpResultDuelMode.loadImage();
    this.f_grpResultDuelMode.updateResult(1, score, this.other_Score);
    this.preventTouchWhenEndGame();
    //Process Win Lose
    this.f_grpTimeDuel.IsStartTime = false;
    //Process Win Lose
    this.f_grpTimeDuel.isEndTime = true;
    this.isShowResultDuelMode = true;
    this.showVideo();
    GlobalSetting.photonManager.leaveRoom();
    
    
}

Level.prototype.resultDuelMode = function(otherPlayerScore) {
    //show UI
	this.f_grpResultDuelMode.endBattle = true;
    this.f_grpResultDuelMode.visible = true;
    this.f_grpResultDuelMode.loadImage();
    this.other_Score = otherPlayerScore;
    if (otherPlayerScore > score) {
        //lose
        this.f_grpResultDuelMode.updateResult(0, score, otherPlayerScore);
    } else if (otherPlayerScore < score) {
        //win
        this.f_grpResultDuelMode.updateResult(1, score, otherPlayerScore);
    } else {
        //draw
        this.f_grpResultDuelMode.updateResult(2, score, otherPlayerScore);
    }

    this.showVideo();

    
}

Level.prototype.preventTouchWhenEndGame = function() {
    currentScenes = SCENES.NONE;
    inputPointEnd.position.setTo(OUT_SIDE_POSITION, OUT_SIDE_POSITION);
    inputPointStart.position.setTo(OUT_SIDE_POSITION, OUT_SIDE_POSITION);
    if (arrowPlayer != undefined) arrowPlayer.visible = false;
    if (arrowEnemy != undefined) arrowEnemy.visible = false;
    this.clearAllArrow();
}

Level.prototype.updateTimeDuelMode = function() {
    if (this.f_grpTimeDuel.updateTime()) {
        this.f_grpTimeDuel.endTime();

        this.preventTouchWhenEndGame();


        options = {};
        options.receivers = Photon.LoadBalancing.Constants.ReceiverGroup.Other;
        var scores = {};
        scores.value = score;
        GlobalSetting.photonManager.onRaiseEvent(6, scores, options);
        //Process Win Lose
        this.f_grpTimeDuel.IsStartTime = false;
    }
}

Level.prototype.setPosition = function(enemyX, enemyY, playerX, playerY) {



    enemy_idle.position.setTo(enemyX, enemyY);
    enemy_shoot.position.setTo(enemyX, enemyY);


    player_idle.position.setTo(playerX, playerY);
    player_shoot.position.setTo(playerX, playerY);

    this.healthBarPosition();
}

Level.prototype.otherPlayerDeath = function() {

    if (this.otherScene === SCENES.SETTING_FADE_PLAYER) {

        this.other_player_fade_time = game.time.totalElapsedSeconds() + this.other_player_duration_fade_time;
        this.other_player_fade_total_time = game.time.totalElapsedSeconds() + (this.other_player_duration_fade_time * FADE_EFFECT_CHARACTER_COUNT);
        this.otherScene = SCENES.FADE_PLAYER;

        if (userType === USERTYPE.CLIENT) {
            if (arrowPlayer != null || arrowPlayer != undefined) {
                arrowPlayer.position.setTo(OUT_SIDE_POSITION, OUT_SIDE_POSITION);
                arrowPlayer.visible = false;
            }
        } else {

            if (arrowEnemy != null || arrowEnemy != undefined) {
                arrowEnemy.position.setTo(OUT_SIDE_POSITION, OUT_SIDE_POSITION);
                arrowEnemy.visible = false;

            }
        }
        console.log("Other Dead");
        this.updateScore(true);


    } else if (this.otherScene === SCENES.FADE_PLAYER) {


        if (game.time.totalElapsedSeconds() >= this.other_player_fade_time) {
            other_player_sprite_death.visible = !other_player_sprite_death.visible;
            this.other_player_fade_time = game.time.totalElapsedSeconds() + this.other_player_duration_fade_time;

        }

        if (game.time.totalElapsedSeconds() >= this.other_player_fade_total_time && !this.isOtherFadeFirst) {

            this.otherScene = SCENES.SHOWEFFECT;
        }
    } else if (this.otherScene === SCENES.SHOWEFFECT) {

        other_player_sprite_death.visible = true;
        other_player_sprite_death.y += CHARACTER_DROP_SPEED;

        if (userType === USERTYPE.CLIENT) {
            this.fTxt_player_01.y += CHARACTER_DROP_SPEED;
        } else {
            this.fTxt_player_02.y += CHARACTER_DROP_SPEED;
        }

        if (other_player_sprite_death.y >= SCREEN_HEIGHT + 300) {



        	this.isShootArrow = false;
            this.otherScene = SCENES.RELOAD;
            this.other_elapsedTime_Reload = game.time.totalElapsedSeconds() + this.other_time_Reload;
        }
        if (userType === USERTYPE.MASTER) {


            for (var i = 0; i < arrowPlayerPool.length; i++) {
                if (player_arrow_collisions[i] === COLLISION.BODY ||
                    player_arrow_collisions[i] === COLLISION.HEAD) {
                    arrowPlayerPool.getAt(i).y += CHARACTER_DROP_SPEED;
                }
            }
        } else {

            for (var i = 0; i < arrowEnemyPool.length; i++) {
                if (enemy_arrow_collisions[i] === COLLISION.BODY ||
                    enemy_arrow_collisions[i] === COLLISION.HEAD) {
                    arrowEnemyPool.getAt(i).y += CHARACTER_DROP_SPEED;
                }
            }
        }

    } else if (this.otherScene === SCENES.RELOAD) {

        if (game.time.totalElapsedSeconds() > this.other_elapsedTime_Reload) {

            this.isOtherPlayerDeath = false;
            this.isPlayerDeath = false;

            if (userType === USERTYPE.CLIENT) {
                //Change position player when enemy reload

                if (arrowPlayer != null || arrowPlayer != undefined) {
                    if (isMouseDrag) {
                        //When player shoot arrow no update new position character
                        arrowPlayer.x = player_idle.x + this.f_grp_characterSkin.currentSettingMaster.position_X_Arrow;
                        arrowPlayer.y = player_idle.y + this.f_grp_characterSkin.currentSettingMaster.position_Y_Arrow;
                    }
                }



                //Active Collider
                player_head_Collider.body.enable = true;
                player_body_Collider.body.enable = true;



                player_current_health = MAX_HEALTH + 1;
                player_health_bar.animations.play('empty');


                if (arrowEnemy != null || arrowEnemy != undefined) {
                    if (isMouseDrag) {
                        //When player shoot arrow no update new position character
                        arrowEnemy.x = enemy_idle.x + this.f_grp_characterSkin.currentSettingClient.position_X_Arrow;
                        arrowEnemy.y = enemy_idle.y + this.f_grp_characterSkin.currentSettingClient.position_Y_Arrow;
                    }
                }

                player_idle.visible = false;
            } else {
                //enemy Reload

                if (arrowPlayer != null || arrowPlayer != undefined) {
                    if (isMouseDrag) {
                        //When player shoot arrow no update new position character
                        arrowPlayer.x = player_idle.x + this.f_grp_characterSkin.currentSettingMaster.position_X_Arrow;
                        arrowPlayer.y = player_idle.y + this.f_grp_characterSkin.currentSettingMaster.position_Y_Arrow;
                    }
                }

                for (var i = 0; i < arrowPlayerPool.length; i++) {
                    if (player_arrow_collisions[i] === COLLISION.HEATH_BAR) {
                        arrowPlayerPool.getAt(i).visible = false;
                        player_arrow_collisions[i] = COLLISION.NONE;
                    }
                }

                //Active Collider
                enemy_head_Collider.body.enable = true;
                enemy_body_Collider.body.enable = true;


                enemy_current_health = MAX_HEALTH + 1;
                enemy_health_bar.animations.play('empty');
                enemy_idle.visible = false;
            }

            this.otherScene = SCENES.NONE;
            this.other_prevent_update_position = true;
            this.other_elapsedTime_wait_Reload = game.time.totalElapsedSeconds() + this.other_time_wait_Reload;
        }
    }


    

}




Level.prototype.hideArrowPauseGame = function(pauseGame) {
   for(var i = 0 ;i<arrowPlayerPool.length ;i++){
       if(pauseGame){
       var arrowVisible = false;
        if(arrowPlayerPool.getAt(i).visible)arrowVisible = true;
        this.arrowPlayerVisiblePauseGame.push(arrowVisible);

        arrowPlayerPool.getAt(i).visible = false;
       }
       else{
           console.log("this.arrowPlayerVisiblePauseGame[i] "+this.arrowPlayerVisiblePauseGame[i] );
        arrowPlayerPool.getAt(i).visible = this.arrowPlayerVisiblePauseGame[i];
       }
   }

   

   for(var i = 0 ;i<arrowEnemyPool.length ;i++){
    if(pauseGame){
    var arrowVisible = false;
    if(arrowEnemyPool.getAt(i).visible)arrowVisible = true;
    this.arrowEnemyVisiblePauseGame.push(arrowVisible);

    arrowEnemyPool.getAt(i).visible = false;
    }
    else{
        arrowEnemyPool.getAt(i).visible = this.arrowEnemyVisiblePauseGame[i];
       }
}

if(!pauseGame){
    this.arrowPlayerVisiblePauseGame = new Array();
    this.arrowEnemyVisiblePauseGame = new Array();
}
}

Level.prototype.joinRoomWithFriend = function() {
	
     //Join Room With Friend
     var nameRoom1 =  FBInstant.player.getID()+"_FRIEND" ;
	var nameRoom2 =  GlobalSetting.entryPointData.Id+"_FRIEND" ;
    options =  {};
    options.isVisible = false;
    userType = USERTYPE.CLIENT;
    GlobalSetting.photonManager.joinRoomFollowName(nameRoom2,options);
    GlobalSetting.photonManager.joinRoomFollowName(nameRoom1,options);
	this.f_grpMapDuel.hideUIjoinWF();
	
	
}

Level.prototype.updateLeaderBoard = function() {
	
    //Update score  to leaderBoard
    this.f_grpLeaderBoardPrefab.updateLeaderBoard(GlobalSetting.leaderBoardScore, localData.BestScore);
    //Update headShot score  to leaderBoard
    this.f_grpLeaderBoardPrefab.updateLeaderBoard(GlobalSetting.leaderBoardHeadShot, localData.BestHeadShot);
}



Level.prototype.settingPlayDuelMode = function() {
	 //Reset Setting Enemy
    enemy_health_bar.visible = true;
    enemy_idle.visible = true;
    enemy_body_Collider.body.enable = true;
    enemy_head_Collider.body.enable = true;
    this.fTxt_player_01.x = player_idle.x+ player_idle.width/2;
    this.fTxt_player_02.x = enemy_idle.x+ enemy_idle.width/2;
    if (userType === USERTYPE.MASTER) {
        enemy_idle.x = ENEMY_POSITION_X_STAND + X_POSITION_ADD_MULTIPLAYER;
        enemy_idle.y = RndPosition(gameHeight() / POSITION_Y_MIN + enemy_idle.height, gameHeight() / POSITION_Y_MAX - enemy_idle.height);
    }

    enemy_current_health = MAX_HEALTH;
    enemy_health_bar.animations.play('full');
    enemy_health_bar.x = enemy_idle.x +this.f_grp_characterSkin.currentSettingClient.position_X_health_bar;
    enemy_health_bar.y = enemy_idle.y +this.f_grp_characterSkin.currentSettingClient.position_Y_health_bar;


    if (userType === USERTYPE.CLIENT) {
        //set name to character
        this.fTxt_player_02.text = facebookStuff.name;
     
        this.fTxt_player_01.text = this.f_grpMapDuel.fTxt_other_player_name_wait.text;
      
        this.f_grp_Tutorial.addColorClient(0xff2403);
      
        line.tint = 0xff2403;
        this.f_grp_Tutorial.f_grp_Master.visible = false;
    } else {
    	 this.f_grp_Tutorial.addColor(0x3684ff);
    	 this.f_grp_Tutorial.f_grp_Client.visible = false;
    	  line.tint = 0x3684ff;
        //set name to character
        this.fTxt_player_01.text = facebookStuff.name;
        this.fTxt_player_02.text = this.f_grpMapDuel.fTxt_other_player_name_wait.text;
    }
    
    this.fTxt_player_02.addColor('#ff2403'); //red
    
    this.fTxt_player_01.addColor('#3684ff'); //blue
    
    console.log("Set Color");
    this.f_grpTimeDuel.fTxt_score_master.addColor('#3684ff');
    this.f_grpTimeDuel.fTxt_score_client.addColor('#ff2403');


    console.log("userType " +userType);
    if (userType === USERTYPE.MASTER) {
    	
        options = {};
        options.receivers = Photon.LoadBalancing.Constants.ReceiverGroup.Others;
        var position = {};
        position.playerX = player_idle.x;
        position.playerY = player_idle.y;
        position.enemyX = enemy_idle.x;
        position.enemyY = enemy_idle.y;
        GlobalSetting.photonManager.onRaiseEvent(4, position, options);
        //Start Time
        
        
      
        

    }
    
    this.f_grpMapDuel.Time.stop();
    
    //down gems when join rooms
    console.log("Down Gems when join Rooms");
    this.f_grpMainMenuPrefab.addGems(-this.f_grpMapDuel.costGemRoomJoin());
    //localData.gems -= this.f_grpMapDuel.costGemRoomJoin();
    //this.saveData();
    
    //Show Total gem win
    this.f_grpTimeDuel.fTxt_total_gems.text  =( this.f_grpMapDuel.winGem()>=1000) ?(this.f_grpMapDuel.winGem()/1000)+"K":this.f_grpMapDuel.winGem() ;
    this.f_grpTimeDuel.startTime();

    this.f_grpTimeDuel.IsStartTime = true;
    this.f_grpTimeDuel.visibletimeUIDuelMode(true);
    
    
    
  
    this.isShowResultDuelMode = false;
   
}


Level.prototype.render = function() {
	
	
    //game.debug.geom(line2,0x000000);
    // console.log("line2" +line2.start);
    //console.log("line2" +line2.end);
    // game.debug.geom(line2,0x000000);
    //Set Size Arrow
    //if(wallGroup.getAt(0).body!=null || wallGroup.getAt(0).body !=undefined){
    //console.log("Has Body");
    //game.debug.body(wallGroup.getAt(0).body);
    // }

    //if(arrowPlayer!=null || arrowPlayer !=undefined){
    //game.debug.body(arrowPlayer);
    //}
    //if(arrowEnemy!=null || arrowEnemy !=undefined){
    // arrowEnemy.body.setSize(100,50,280 - Math.cos(arrowEnemyObject.rotation) *30,-Math.sin(arrowEnemyObject.rotation) * 300);

    // game.debug.body(arrowEnemy);
    //}

    
    //game.debug.body(player_head_Collider);
   // game.debug.body(player_body_Collider);
   // game.debug.body(enemy_body_Collider);
   // game.debug.body(enemy_head_Collider);
	
   
	 	var x =32 ;
     	var y = 20 ;
         var i = 20;
         //game.debug.gameInfo(x, y);
   //game.debug.gameTimeInfo(x, y);
     // if( GlobalSetting.entryPointData  !=undefined)
    //  this.game.debug.text("Connect : " + this.resultDuel, x, y+=i);
     // this.game.debug.text("Again : " + level.stringSFX, x, y+=i);
      
    //  this.game.debug.text("BGMVolume :" + GlobalSetting.BGMVolume, x, y+=i);
     // this.game.debug.text("FPS : " + this.game.time.fps, x, y+=i);
     // this.game.debug.text("Case Watch Video : " +this.caseWatchRewardVideo , x, y+=i);
    
    
    
   
};

// =====================region Event Button Click===========================
Level.prototype.OnMouseDrag = function() {
    if (isMouseDrag) {
        if (this.isPreventClickWhenDeath) return;
        this.inputPointEnd.x = this.input.activePointer.x;
        this.inputPointEnd.y = this.input.activePointer.y;
    }
}
Level.prototype.OnMouseDown = function() {


    if (this.game.input.activePointer.isDown) {



        
        if (this.isCancelClick) return;


        this.f_grp_Tutorial.visible = false;
        
        if (this.isPreventClickWhenDeath) {
            player_shoot.visible = true;
            return;
        }

        if (userType === USERTYPE.MASTER) {
            player_shoot.visible = true;
            player_idle.visible = false;
            player_shoot.x = player_idle.x;
            player_shoot.y = player_idle.y;
        } else {
            enemy_shoot.visible = true;
            enemy_idle.visible = false;
            enemy_shoot.x = enemy_idle.x;
            enemy_shoot.y = enemy_idle.y;
        }




        if (!isMouseDrag) {
            this.inputPointStart.x = this.input.activePointer.x;
            this.inputPointStart.y = this.input.activePointer.y;
            this. inputPointEnd.x = this.input.activePointer.x;
            this.inputPointEnd.y = this.input.activePointer.y;

            isMouseDrag = true;
            isShoot = true;
            if (userType === USERTYPE.MASTER) {
                arrowPlayer = getArrow(arrowPlayerPool, player_arrow_collisions, player_idle.x + this.f_grp_characterSkin.currentSettingMaster.position_X_Arrow
                    , player_idle.y +this.f_grp_characterSkin.currentSettingMaster.position_Y_Arrow, true);
            } else {
                arrowEnemy = getArrow(arrowEnemyPool, enemy_arrow_collisions, enemy_idle.x +this.f_grp_characterSkin.currentSettingClient.position_X_Arrow,
                     enemy_idle.y + this.f_grp_characterSkin.currentSettingClient.position_Y_Arrow, false); //61
            }

        }
    }
}


Level.prototype.onMouseDownOtherPlayer = function() {
    if (userType === USERTYPE.CLIENT) {
        player_shoot.visible = true;
        player_idle.visible = false;
        player_shoot.x = player_idle.x;
        player_shoot.y = player_idle.y;
    } else {
        enemy_shoot.visible = true;
        enemy_idle.visible = false;
        enemy_shoot.x = enemy_idle.x;
        enemy_shoot.y = enemy_idle.y;
    }


    if (userType === USERTYPE.CLIENT) {
        arrowPlayer = getArrow(arrowPlayerPool, player_arrow_collisions, player_idle.x +this.f_grp_characterSkin.currentSettingMaster.position_X_Arrow
            , player_idle.y + this.f_grp_characterSkin.currentSettingMaster.position_Y_Arrow, true);
    } else {
        arrowEnemy = getArrow(arrowEnemyPool, enemy_arrow_collisions, enemy_idle.x + this.f_grp_characterSkin.currentSettingClient.position_X_Arrow,
             enemy_idle.y + this.f_grp_characterSkin.currentSettingClient.position_Y_Arrow, false); //61
    }
}

Level.prototype.OnMouseUpOtherPlayer = function() {


    if (userType === USERTYPE.CLIENT) {
        player_shoot.visible = false;
        player_idle.visible = true;
        player_shoot.x = player_idle.x;
        player_shoot.y = player_idle.y;
    } else {
        enemy_shoot.visible = false;
        enemy_idle.visible = true;
        enemy_shoot.x = enemy_idle.x;
        enemy_shoot.y = enemy_idle.y;
    }


}

Level.prototype.OnMouseUp = function() {
    if (this.game.input.activePointer.isUp) {
    	
    	if(this.playMode === PLAYMODE.SINGLE && player_current_health <=0) {
    		console.log("Return");
    		return;
    	}
    	
        if (userType === USERTYPE.MASTER) {
            player_shoot.visible = false;
            player_idle.visible = true;
            player_shoot.x = player_idle.x;
            player_shoot.y = player_idle.y;
        } else {
            enemy_shoot.visible = false;
            enemy_idle.visible = true;
            enemy_shoot.x = enemy_idle.x;
            enemy_shoot.y = enemy_idle.y;
        }




        isMouseDrag = false;
        this.inputPointStart.x = OUT_SIDE_POSITION;
        this.inputPointStart.y = OUT_SIDE_POSITION;
        this.inputPointEnd.x = OUT_SIDE_POSITION;
        this.inputPointEnd.y = OUT_SIDE_POSITION;
        this.isPreventClickWhenDeath = false;

        if (isShoot) {
        	
        	
        	
        	
        	
            //Play sfx
            this.game.sound.play("sfx_arrow_fly", GlobalSetting.SEVolume);
            player_number_arrow_shoot++;
            player_arrow_count_hit_something++;
            isFirstTime = true;
           // this.f.visible = !isFirstTime;
          
            if (userType === USERTYPE.MASTER) {
                shootArrow(arrowPlayer, arrowSpeed, player_bow.rotation);

            } else {
                //console.log("Arrow Speed " +arrowSpeed);
                shootArrow(arrowEnemy, -arrowSpeed, -enemy_bow.rotation);
            }

            console.log("In " +player_current_health);
            this.isShootArrow = true;
            isShoot = false;

            if (this.isPlayerReloadWhenClick) {
            	this.isShootArrow = false;
                this.isPlayerReloadWhenClick = false;
            }

        }

    }
}

Level.prototype.onEventMenuDuel = function() {
    this.f_grpMapDuel.visibileMenuDuel(true);
}

Level.prototype.onEventOpenWorldMap = function() {
    //Show World Map
    this.f_grpWorldMapScene.visibleScene(true);
   	this.f_grpWorldMapScene.setPlayerStand(	this.f_grpWorldMapScene.maxPoint);
    this.f_grpWorldMapScene.scrollTo();
    this.f_grpLeaderBoardPrefab.visible = false;
    this.f_grpInforPrefab.visible = false;
    //Show current Button control
}
Level.prototype.onEventGoHome = function() {
    //Show World Map
    this.f_grpWorldMapScene.visibleScene(false);
    this.f_grpLeaderBoardPrefab.visible = false;
    this.f_grpInforPrefab.visible = false;
    //Show current Button control
    this.f_grpMainMenuPrefab.activeControlButton(1);
}

Level.prototype.onEventLeaderBoard = function() {
    //Show World Map
    this.f_grpWorldMapScene.visibleScene(false);
    this.f_grpLeaderBoardPrefab.visible = true;

    // this.f_grpLeaderBoardPrefab.getLeaderBoard();
    this.f_grpLeaderBoardPrefab.onEventGlobal();
    this.f_grpInforPrefab.visible = false;
    
    this.f_grpLeaderBoardPrefab.activeControlButton(0);
    //Show current Button control
    // console.log("_mainMenuPreFab " +this.f_grpMainMenuPrefab);
    this.f_grpMainMenuPrefab.activeControlButton(2);
}

Level.prototype.onEventInfor = function() {
    //Show World Map
    this.f_grpWorldMapScene.visibleScene(false);
    this.f_grpLeaderBoardPrefab.visible = false;
    this.f_grpMainMenuPrefab.activeControlButton(3);
    
    this.f_grpInforPrefab.visible = true;
    this.f_grpInforPrefab.updateInformation(localData.Score, localData.HeadShot, localData.Efficiency);
}

//Event Click Play Game
Level.prototype.onPlayClick = function() {

    this.initGamePlay();
    
   
    if (this.playMode != PLAYMODE.SINGLE) {
        this.isMessageHandler = true;
    }
}


Level.prototype.initGamePlay = function() {

    //Add BGM 

    
	 
    GlobalSetting.BGM = null;

    //GlobalSetting.BGM = game.sound.play("BGM", GlobalSetting.BGMVolume);
    GlobalSetting.BGM = game.sound.play("BGM", GlobalSetting.BGMVolume);
	GlobalSetting.BGM.loopFull();
    //reset enemy kill count
    this.enemy_kill_count = 0;

   

    this.f_grpMainMenuPrefab.visible = false;
    this.f_grpMapDuel.visible = false;
    this.f_grpMapDuel.visibileMenuDuel(false);
    this.f_grpMainMenuPrefab.openWorldMap();
    this.f_grpWorldMapScene.visibile = false;
    this.f_grpWorldMapScene.visibleScene(false);
    //this.fBg_MainMenu.visible = false;

    //Show Score text
    this.visibleTextScoreGamePlay(true);
    this.resetScore();
    sceneState  =  STATES.PLAY;
    currentScene = SCENES.PLAY;



    player_number_arrow_shoot = 0;
    //Reset Setting Player
   
    player_body_Collider.body.enable = true;
    player_head_Collider.body.enable = true;

    if (userType === USERTYPE.MASTER) {
        level.f_grp_characterSkin.loadPlayerMaster(localData.currentSkin,localData.currentBow);
        player_idle.x = PLAYER_POSITION_X_STAND;
        player_idle.y = RndPosition(gameHeight() / POSITION_Y_MIN + player_idle.height, gameHeight() / POSITION_Y_MAX - player_idle.height);
    }
    

    for (var i = 0; i < arrowsPlayerBody.length; i++) {
        arrowsPlayerBody[i] = null;
    }
    arrowPlayerBodyIndex = 0;
    player_current_health = MAX_HEALTH;
    player_health_bar.animations.play('full');

    player_health_bar.visible = true;



    this.f_grp_Tutorial.visible = !isFirstTime;



    isUpdateDifficult = true;
    for (var i = 0; i < wallGroup.length; i++) {
        wallGroup.getAt(i).visible = false;
    }
    this.fWall_1.y = RndPosition(WALL_LIMIT_TOP, WALL_LIMIT_BOTTOM);


    //Reset Position of Cloud
    for (var i = 0; i < this.clouds.length; i++) {
        this.clouds[i].x = this.cloudsPosition[i];
    }




    if (this.playMode === PLAYMODE.SINGLE) {
        //level.f_grp_characterSkin.loadPlayerMaster(localData.currentSkin,localData.currentBow);
    	this.f_grp_Tutorial.addColor(0xFFFF00);
    	 this.f_grp_Tutorial.f_grp_Client.visible = false;
    	this.Time.start();
    	line.tint = 0xFFFF00;
    	this.elapsedTime_Single_Mode = 0;
    	 this.f_grpTimeDuel.visibletimeUIDuelMode(false);
        //Reset Setting Enemy
        enemy_health_bar.visible = true;
        enemy_idle.visible = true;
        enemy_body_Collider.body.enable = true;
        enemy_head_Collider.body.enable = true;
        enemy_idle.x = ENEMY_POSITION_X_STAND;
        enemy_idle.y = RndPosition(gameHeight() / POSITION_Y_MIN + enemy_idle.height, gameHeight() / POSITION_Y_MAX - enemy_idle.height);

        enemy_current_health = MAX_HEALTH;
        enemy_health_bar.animations.play('full');
        enemy_health_bar.x = enemy_idle.x - 22;
        enemy_health_bar.y = enemy_idle.y + 107;
        enemyState = ENEMYSTATE.IDLE;
        enemy_elapsed_idle_time = game.time.totalElapsedSeconds() + enemy_idle_time;
        //set name to character
        this.fTxt_player_01.text = facebookStuff.name;
        this.fTxt_player_01.x = player_idle.x+ player_idle.width/2;
        this.healthBarPosition();
        this.f_grp_PauseMenu.visible = true;
       
    } else {
        
       this.settingPlayDuelMode();


    }


    //player_idle.visible = false;

    

    
    this.f_grpTimeDuel.visible = true;
    this.isPlayGame = true;
    this.healthBarPosition();

}
//Event CLick LeaderBoard

//=====================endregion======================================================
Level.prototype.playerReload = function() {

    //Change position player when enemy reload

    var tempSprite = (player_idle.visible) ? player_idle : player_shoot;
    player_health_bar.x = tempSprite.x - 7; //14
    player_health_bar.y = tempSprite.y + 119; //119

    if (arrowPlayer != null || arrowPlayer != undefined) {
        if (isMouseDrag) {
            //When player shoot arrow no update new position character
            arrowPlayer.x = player_idle.x + this.f_grp_characterSkin.currentSettingMaster.position_X_Arrow;
            arrowPlayer.y = player_idle.y + this.f_grp_characterSkin.currentSettingMaster.position_Y_Arrow;
        }
    }

    //Active Collider
    player_head_Collider.body.enable = true;
    player_body_Collider.body.enable = true;



    player_current_health = MAX_HEALTH;
    player_health_bar.animations.play('full');
    currentScene = SCENES.PLAY;
    this.isPlayerDeath = false;

    if (arrowEnemy != null || arrowEnemy != undefined) {
        if (isMouseDrag) {
            //When player shoot arrow no update new position character
            arrowEnemy.x = enemy_idle.x + this.f_grp_characterSkin.currentSettingClient.position_X_Arrow;
            arrowEnemy.y = enemy_idle.y + this.f_grp_characterSkin.currentSettingClient.position_Y_Arrow;
        }
    }

    player_arrow_count_hit_something = 0;


}

Level.prototype.enemyReload = function() {

    if (this.playMode === PLAYMODE.SINGLE) {
        //Change position player when enemy reload
        player_idle.x = PLAYER_POSITION_X_STAND;
        player_idle.y = RndPosition(gameHeight() / POSITION_Y_MIN + player_idle.height, gameHeight() / POSITION_Y_MAX - player_idle.height);
        this.healthBarPosition();
    }

    var tempSprite = (player_idle.visible) ? player_idle : player_shoot;
    player_health_bar.x = tempSprite.x - 7; //14
    player_health_bar.y = tempSprite.y + 119; //119

    if (arrowPlayer != null || arrowPlayer != undefined) {
        if (isMouseDrag) {
            //When player shoot arrow no update new position character
            arrowPlayer.x = player_idle.x + this.f_grp_characterSkin.currentSettingMaster.position_X_Arrow;
            arrowPlayer.y = player_idle.y + this.f_grp_characterSkin.currentSettingMaster.position_Y_Arrow;
        }
    }

    console.log("Enemy Reload");




    //Reset Setting Enemy
    if (this.playMode === PLAYMODE.SINGLE) {
        enemy_idle.x = ENEMY_POSITION_X_STAND;

        enemy_idle.y = RndPosition(gameHeight() / POSITION_Y_MIN + enemy_idle.height, gameHeight() / POSITION_Y_MAX - enemy_idle.height);
    }

    if (enemy_sprite_death != undefined) {
        enemy_sprite_death.y = enemy_idle.y;
        enemy_sprite_death.visible = false;
    }
    enemy_idle.visible = true;


    enemy_current_health = MAX_HEALTH;
    enemy_health_bar.animations.play('full');

    if (userType === USERTYPE.CLIENT) {
        currentScene = SCENES.PLAY;
        this.isPlayerDeath = false;
        // this.isPlayerDeath =false;
    }

    for (var i = 0; i < arrowPlayerPool.length; i++) {
        if (player_arrow_collisions[i] === COLLISION.HEATH_BAR) {
            arrowPlayerPool.getAt(i).visible = false;
            player_arrow_collisions[i] = COLLISION.NONE;
        }
    }

    //Active Collider
    enemy_head_Collider.body.enable = true;
    enemy_body_Collider.body.enable = true;

    //Set Enemy Health Bar
    enemy_health_bar.visible = true;
    enemyState = ENEMYSTATE.IDLE;
    enemy_elapsed_idle_time = game.time.totalElapsedSeconds() + enemy_idle_time;

    if (this.playMode === PLAYMODE.SINGLE) {
        enemy_health_bar.x = enemy_idle.x - 22;
        enemy_health_bar.y = enemy_idle.y + 107;
    } else {
        enemy_health_bar.x = enemy_idle.x - 100;
        enemy_health_bar.y = enemy_idle.y + 117;
    }

    if (score <= this.EASY_MODE)
        this.enemy_arrow_number_miss = 3;
    else
        this.enemy_arrow_number_miss = 1;

    player_arrow_count_hit_something = 0;
}




//=====================#region Logic Game================================================================
Level.prototype.Init = function() {
    this.scale.scaleMode = Phaser.ScaleManager.SHOW_ALL;
    game.scale.fullScreenScaleMode = Phaser.ScaleManager.EXACT_FIT;//SHOW_ALL


   // var plugin = game.plugins.add(Phaser.Plugin.AdvancedTiming);

   // plugin.mode = 'text';


 
}

Level.prototype.Create = function() {
   
    
	this.stringSFX  = "";
	this.resultDuel = "";
	this.gemValue = "";
    this.log1 ="";
    if (GlobalSetting.BGM != undefined){
    	 
        GlobalSetting.BGM.stop();
        GlobalSetting.BGM = null;
    }

    this.debugRewardVideo = "";
    this.caseWatchRewardVideo = 0;
    isMessageUpdateHealth = false;
    time_prevent_Message = 1;
    elapsedtime_Message = game.time.totalElapsedSeconds() + time_prevent_Message + 10;
    this.isMessageHandler = false;
    level = this;
    this.isPlayGame = false;
    //	this.leaderBoard =  new leaderBoard();
    //this.leaderBoard.print();
    this.isShowResultDuelMode = true;
    
    this.enemy_kill_count = 0;
    this.Time = this.time.create();
    this.elapsedTime_Single_Mode  = 0;
    this.ImageBase64 = new imageBase64();
    
    //Player var
    this.point_player_top;
    this.point_player_bottom;
    this.player_time_Reload = 1;
    this.player_elapsedTime_Reload = 0;
    this.player_time_wait_Reload = 0.5;
    this.player_elapsedTime_wait_Reload = 0;
    this.player_next_Point_X = 0;
    this.player_next_Point_Y = 0;
    this.enemy_next_Point_X = 0;
    this.enemy_next_Point_Y = 0;
    this.isPlayerReloadWhenClick = false;
    this.isPreventClickWhenDeath = false;
    this.isPositionGenerated = false;
    this.isShootArrow = false;
    isShoot = false;
    //Other Player
    this.other_player_fade_time = 0;
    this.other_player_fade_total_time = 0;
    this.other_player_duration_fade_time = 0.15;
    this.other_player_sprite_death;
    this.other_pointer_down = false;
    this.other_shoot_arrow = false;
    this.other_arrow_Speed = 0;
    this.other_time_Reload = 0.75;
    this.other_elapsedTime_Reload = 0;
    this.other_time_wait_Reload = 1.5;
    this.other_elapsedTime_wait_Reload = 0;
    this.other_prevent_update_position = false;
    this.other_next_Point_X = 0;
    this.other_next_Point_Y = 0;
    this.other_Score = 0;
    this.other_reload = false;
    this.point_height = 400;
    this.other_time_reset_speed = 0.7;
    this.other_elapsedTime_reset_speed = 0;
    this.other_arrow_count_shoot = 0;
    this.isOtherPlayerDeath = false;
    this.isPlayerDeath = false;
    this.isOtherFadeFirst = false;

    this.arrowPlayerVisiblePauseGame = new Array();
    this.arrowEnemyVisiblePauseGame = new Array();
    this.arrowPlayerVisible = false;
    this.arrowEnemyVisible = false;



    this.inputPointStart = this.fInput_Point_Start;
    this.inputPointEnd = this.fInput_Point_End;

    this.jsonMessage;
    this.scoreMulti = new scoreMultiplayer();

    //Enemy Var
    this.enemy_target_rnd_y = 0;
    this.enemy_kill = 0;

    this.enemy_shoot_time = 1.5;
    //Arrow enemy shoot random
    this.enemy_arrow_random_count = 0;
    //number arrow enemy shoot miss and change to shoot correct
    this.enemy_arrow_number_miss = RndPosition(1, 3);

    this.wait_time_load_video_ADS = 1.5;
    this.elapsedtime_load_video_ADS = 0;

    this.isCancelClick = false; //when press button cancel mouse press
    this.CLOUD_SPEED = 0.2;
    this.clouds = new Array();
    this.cloudsPosition = new Array();
    //Add Cloud
    this.clouds.push(this.fCloud1);
    this.cloudsPosition.push(this.fCloud1.x);
    this.clouds.push(this.fCloud2);
    this.clouds.push(this.fCloud3);
    this.clouds.push(this.fCloud4);
    this.clouds.push(this.fCloud5);
    this.clouds.push(this.fCloud6);
    //Add Postion Start of Cloud
    this.cloudsPosition.push(this.fCloud1.x);
    this.cloudsPosition.push(this.fCloud2.x);
    this.cloudsPosition.push(this.fCloud3.x);
    this.cloudsPosition.push(this.fCloud4.x);
    this.cloudsPosition.push(this.fCloud5.x);
    this.cloudsPosition.push(this.fCloud6.x);



    //Score var
    this.SCORE_HEAD_SHOT = 4;

    //MODE GAME FOLLOW ENEMY KILL
    this.EASY_MODE = 10;
    this.NORMAL_MODE = 10;
    this.GRAVITY_FORCE_EASY_MODE = 200;
    this.GRAVITY_FORCE_HARD_MODE = 200;

    this.playMode = PLAYMODE.SINGLE;

    this.otherScene = SCENES.NONE;
    sceneState = STATES.MAINMENU;
  
    //Setting width and height screen

    SCREEN_WIDTH = game.width; // window.screen.width;
    SCREEN_HEIGHT = game.height; //window.screen.height;

    game.physics.startSystem(Phaser.Physics.ARCADE);
    btn_play = this.fPlay_button;


    title_game_sheet = this.fTitle_game;
    gameover_group = this.fGameOver_Group;
    btn_relay = this.fBtn_Replay;
    btn_menu = this.fBtn_menu;
    btn_leaderBoard = this.fBtn_leadBoard;

 
    player_head_Collider = this.fPlayer_Head_Collider;
    player_body_Collider = this.fPlayer_Body_Collider;
    player_health_bar = this.fPlayer_health;
    arrowObject = this.fArrow_sheet;
    player_head_shoot = this.fPlayer_head_Shoot;
    player_Arrow_Group = this.fPlayer_Arrow;
    //Add Physic for body and head 
    game.physics.arcade.enable(player_head_Collider);
    player_head_Collider.body.allowGravity = false;
    game.physics.arcade.enable(player_body_Collider);
    player_body_Collider.body.allowGravity = false;
    game.physics.arcade.enable(player_health_bar);
    player_health_bar.body.allowGravity = false;


    player_arrow_Collider = this.fPlayer_Arrow_Collider;

    arrowEnemy = undefined;
    arrowPlayer = undefined;
    // Enemy Setting


    enemy_bow = this.fEnemy_bow;
    enemy_idle = this.fEnemy_idle;

    enemy_left_shoot = this.fEnemy_left_shoot;
    enemy_shoot = this.fEnemy_Shoot;
    enemy_shoot.visible = false;
    enemy_head_Collider = this.fEnemy_Head_Collider;
    enemy_body_Collider = this.fEnemy_Body_Collider;
    enemy_health_bar = this.fEnemy_health;
   
    enemy_head_Shoot = this.fEnemy_head_Shot;
    enemy_head_Shoot.visible = false;
    enemy_head_Shoot.scale.setTo(0);
    arrowEnemyObject = this.fEnemy_Arrow_sheet;
    //Add Physic for body and head 
    game.physics.arcade.enable(enemy_health_bar);
    enemy_health_bar.body.allowGravity = false;
    game.physics.arcade.enable(enemy_head_Collider);
    enemy_head_Collider.body.allowGravity = false;
    game.physics.arcade.enable(enemy_body_Collider);
    enemy_body_Collider.body.allowGravity = false;

    this.visibleTextScoreGamePlay(false);


    txt_score_gameOver = this.fTxt_score_gameOver;
    txt_bestScore_gameOver = this.fTxt_bestscore_gameOver;

    // Tutorial 

    this.f_grp_Tutorial.visible = false;

    line = this.fLine;


    inputPointStart = this.fInput_Point_Start;
    inputPointEnd = this.fInput_Point_End;


    // Turn on gravity
    this.game.physics.arcade.gravity.y = this.GRAVITY_FORCE_EASY_MODE;
    // Active Collider


    this.createArrow();

    this.isShootArrow = false;
    wallGroup = this.game.add.group();
    wallGroup.add(this.fWall_1);
    wallGroup.add(this.fWall_2);
    wallGroup.add(this.fWall_3);
    wallGroup.add(this.fWall_4);
    //Add physic for wall
    game.physics.enable(wallGroup.getAt(0), Phaser.Physics.ARCADE);
    wallGroup.getAt(0).body.enable = false;




    line1 = new Phaser.Line(0, SCREEN_HEIGHT / (POSITION_Y_MIN), game.width, SCREEN_HEIGHT / (POSITION_Y_MIN));
    line2 = new Phaser.Line(0, 690, game.width, 690);




    //Get data to PlayFab and update to local
    bestEfficiency = localData.BestEfficiency;
    bestHeadShot = localData.BestHeadShot;
    bestScore = localData.BestScore;
    
    
   
   
   
    //Language
    this.Language = new language();
    this.Language.updateLanguage(localData.languageIndex);
    
    this.f_grpMainMenuPrefab.Init(this);
    this.f_grpLeaderBoardPrefab.Init(this);
    this.f_grpMapDuel.Init(this);

   


   


    

    this.f_grp_buyNotification.visible  = false;
    this.f_grpMap.visible = false;
    this.f_grpResultDuelMode.visible = false;
    this.f_grpLeaderBoardPrefab.visible = false;
    this.f_grpInforPrefab.visible = false;
    this.f_grp_GameOver.visible = false;
    this.f_grp_Terms.visible = false;
    this.f_grp_IAP.visible =false;
    this.f_grp_PauseMenu.visible =false;
    this.f_grp_SelectStagePrefab.visible = false;
    this.f_grp_Terms.visibleTerms(false);
    this.f_grp_PauseMenu.position.setTo(0, 0); 
    this.f_grp_SelectStagePrefab.position.setTo(0, 0); 
    this.f_grp_buyNotification.position.setTo(0, 0);
    this.f_grp_IAP.position.setTo(0, 0); 
    this.f_grp_Terms.position.setTo(0, 0); 
    this.f_grp_GameOver.position.setTo(0, 0); 
    this.f_grpResultDuelMode.position.setTo(0, 0);
    this.f_grpInforPrefab.position.setTo(0, 0);
    this.f_grpLeaderBoardPrefab.position.setTo(0, 0);
    this.f_grpMainMenuPrefab.position.setTo(0, 0);
    this.f_grpWorldMapScene.position.setTo(0, 0);
    this.f_grpMapDuel.position.setTo(0, 0);
    this.f_grpTimeDuel.position.setTo(0, 0);
    this.f_grpMap.position.setTo(0, 0);
    this.f_grpMapDuel.visible = false;
    this.f_grpTimeDuel.visible = false;

    this.f_grpMainMenuPrefab.fProfile_Picture.loadTexture("profilePicture");
    this.f_grpMainMenuPrefab.fProfile_Picture.width = 152;
    this.f_grpMainMenuPrefab.fProfile_Picture.height = 147;
    this.f_grpMapDuel.visible = false;


    this.f_grpMapDuel.fProfile_Picture.loadTexture("profilePicture");

    this.f_grpMapDuel.fProfile_Picture.width = 152;
    this.f_grpMapDuel.fProfile_Picture.height = 147;

    this.f_grpMapDuel.fProfile_Picture_wait.loadTexture("profilePicture");
    this.f_grpMapDuel.fProfile_Picture_wait.width = 148;
    this.f_grpMapDuel.fProfile_Picture_wait.height = 143;
    
    this.f_grpTimeDuel.fPlayer_picture.loadTexture("profilePicture");
    this.f_grpTimeDuel.fPlayer_picture.width = 97;
    this.f_grpTimeDuel.fPlayer_picture.height = 85;

    this.updateLeaderBoard();
    
    //check gems when NAN
    if(!isNaN(localData.gems)){
    	if(localData.gems != null){
    		backUpGems =localData.gems  ;
    	}
    	else{
    		localData.gems = backUpGems   ;
    	}
    }
    else{
    	localData.gems = backUpGems   ;
    }
    
   
    
    this.saveData();
    
   // console.log("localData.gems " +localData.gems);
    this.f_grpMainMenuPrefab.updateGemCoin(localData.gems,localData.coins);
    
    
    if(GlobalSetting.entryPointData != undefined){
    	this.f_grpMainMenuPrefab.visible = false;
    	this.joinRoomWithFriend();
    	
    }
    


    this.getImageFriendList();

    //Load Global LeaderBoard
   //this.f_grpLeaderBoardPrefab.onEventGlobal();

   //this.f_grpLeaderBoardPrefab.killScroll();
   

}
Level.prototype.getImageFriendList = function(){

    friendList = new Array();
    friendListID = new Array();
    friendListPhoto = new Array();
    var connectedPlayers = FBInstant.player.getConnectedPlayersAsync()
    .then(function(players) {
        //console.log("Player " +players);
        for (var i = 0; i < players.length; i++) {
           
            friendList.push(players[i]);
           
            friendListID.push(players[i].getID());
            friendListPhoto.push(players[i].getPhoto());
          
        }



        loader = new Phaser.Loader(game);
        loader.crossOrigin = "anonymous";
  
        //load image friend
        for (var i = 0; i < friendListPhoto.length; i++) {
            loader.image("friend"+friendListID[i], friendListPhoto[i]);
        }
      
          loader.image("clientOtherPlay",GlobalSetting.clientPhoto);
        
        console.log("client " +GlobalSetting.clientPhoto);
        loader.start();

           
       
        
       
    });
    setTimeout(function () {
        if(GlobalSetting.clientPhoto ==="") return;
        level.f_grpMainMenuPrefab.loadImageOtherPlayer("clientOtherPlay");
    }, 500);

   
    
   
}

Level.prototype.createArrow = function() {
    //if( GlobalSetting.isLoadArrow ) return;
    this.f_grp_characterSkin.createArrow();



    //Setting arrow Enemy
    arrowEnemyPool = this.game.add.group();
    arrowEnemyVisible = new Array();
    arrowEnemyElapsedTime = new Array();
    enemy_arrow_collisions = new Array();
    for (var i = 0; i < NUMBER_OF_ARROWS; i++) {
        var arrow = this.add.sprite(999.0, 999.0, 'characterAtlas', 'Arrow_01', enemy_shoot);
        arrow.scale.setTo(arrowEnemyObject.scale.x, arrowEnemyObject.scale.y);
        arrow.anchor.setTo(0.0, 0.5);
        arrow.animations.add('hit', ['Arrow_02'], 60, false);
        arrow.animations.add('full', ['Arrow_01'], 60, false);
        arrowEnemyPool.add(arrow);
        arrowEnemyVisible.push(false);
        arrowEnemyElapsedTime.push(0);
        enemy_arrow_collisions.push(COLLISION.NONE);
        // Hide Arrow
        arrowEnemyPool.getAt(i).visible = false;
        // Enable physics on the Arrow
        game.physics.enable(arrow, Phaser.Physics.ARCADE);
        // Set its initial state to "dead".
        arrow.body.allowGravity = false;
        arrow.kill();
    }

    GlobalSetting.isLoadArrow = true;

   
}



Level.prototype.flyCloud = function() {

    for (var i = 0; i < this.clouds.length; i++) {
        this.clouds[i].x += this.CLOUD_SPEED;

        if (this.clouds[i].x >= game.width + this.clouds[i].width) {
            //Reset Cloud
            this.clouds[i].x = 0 - this.clouds[i].width - 1500;
            this.clouds[i].y = RndPosition(100, 680);
            var scaleCloud = RndPosition(0.75, 1);
            this.clouds[i].scale.setTo(scaleCloud);

        }
    }
}

Level.prototype.setPlayMode = function(playMode) {

    this.playMode = playMode;
}

Level.prototype.setSizeCollider = function() {

    if (arrowPlayer != null || arrowPlayer != undefined) {
        var per = -Math.sin(arrowPlayer.rotation) * 4.8;
        if (per === 0) per = 1;
        var y = Math.sin(arrowPlayer.rotation) * ((Math.sin(arrowPlayer.rotation) / per) * 1000);
        var x = (1 - Math.cos(arrowPlayer.rotation)) * 400;
        if (arrowPlayer.body != null || arrowPlayer.body != undefined)
            arrowPlayer.body.setSize(20, 20, 315 - x, -y);

    }
    if (arrowEnemy != null || arrowEnemy != undefined) {
        var per = -Math.sin(arrowEnemy.rotation) * 4.8;
        if (per === 0) per = 1;
        var y = Math.sin(arrowEnemy.rotation) * ((Math.sin(arrowEnemy.rotation) / per) * 1000);
        var x = (1 - Math.cos(arrowEnemy.rotation)) * 400;
        if (arrowEnemy.body != null || arrowEnemy.body != undefined)
            arrowEnemy.body.setSize(20, 20, 315 - x, y);
    }

    if(this.playMode === PLAYMODE.SINGLE){
        if (enemy_body_Collider.body != null || enemy_body_Collider.body != undefined)
            enemy_body_Collider.body.setSize(50, 60, 0, 0);
        if (enemy_head_Collider.body != null || enemy_head_Collider.body != undefined)
            enemy_head_Collider.body.setSize(50, 40, 0, 0);
        }
    else{
        if (enemy_body_Collider.body != null || enemy_body_Collider.body != undefined)
        enemy_body_Collider.body.setSize(this.f_grp_characterSkin.currentSettingClient.body_X_Size, this.f_grp_characterSkin.currentSettingClient.body_Y_Size, 0, 0);
        if (enemy_head_Collider.body != null || enemy_head_Collider.body != undefined)
        enemy_head_Collider.body.setSize(this.f_grp_characterSkin.currentSettingClient.head_X_Size, this.f_grp_characterSkin.currentSettingClient.head_Y_Size, 0, 0);
    }
    





    if (player_body_Collider.body != null || player_body_Collider.body != undefined)
        player_body_Collider.body.setSize(this.f_grp_characterSkin.currentSettingMaster.body_X_Size, this.f_grp_characterSkin.currentSettingMaster.body_Y_Size, 0, 0);

    if (player_head_Collider.body != null || player_head_Collider.body != undefined)
        player_head_Collider.body.setSize(this.f_grp_characterSkin.currentSettingMaster.head_X_Size, this.f_grp_characterSkin.currentSettingMaster.head_Y_Size, 0, 0);
}


Level.prototype.updateScoreMultiplayer = function(value) {
    //Add Score
    this.other_Score = value;
    this.f_grpTimeDuel.updateScore(value);

}


Level.prototype.updateScore = function(multi) {
    //Add Score
    //if kill on first shot, then 5 points
    //If 2 attempts, then only 3 points
    //If 3 attempts then only 2 point
    //If 4+ attempts then 1 points
    var calScore = this.SCORE_HEAD_SHOT - player_arrow_count_hit_something + 1;
    calScore = (calScore >= 4) ? 5 : calScore;
    calScore = (calScore <= 0) ? 1 : calScore;
    score += calScore;
   


    //Check high score; 
    player_number_arrow_shoot = (player_number_arrow_shoot === 0) ? 1 : player_number_arrow_shoot;
    //Update best score
    bestScore = (score > bestScore) ? score : bestScore;


    if (multi) {

        console.log("Send Score " + score);
        options = {};
        options.receivers = Photon.LoadBalancing.Constants.ReceiverGroup.Others;
        var scores = {};
        scores.value = score;
        GlobalSetting.photonManager.onRaiseEvent(5, scores, options);
        this.f_grpTimeDuel.updateLocalScore(score);
    } else {
        //add score
    	 this.enemy_kill_count ++;
    	
    	 if(this.enemy_kill_count >=3){
    		 this.Time.stop();
    		 
    	 }
    	 else{
    		 this.elapsedTime_Single_Mode  = this.Time.seconds;
    	 }
       this.f_grpTimeDuel.updateScoreSingleMode(score);
    }

    player_arrow_count_hit_something = 0;
}

Level.prototype.updateEfficiency = function() {
    if (player_number_arrow_shoot >= effeiciency_number_arrow_update) {

        effeiciency_number_arrow_update = player_number_arrow_shoot + MAX_ARROW_UPDATE_EFFICIENCY;
        var scoreEfficiency = parseFloat(efficiency / player_number_arrow_shoot).toFixed(2) * 100;
        //console.log("Update Eff " +scoreEfficiency);
        //	console.log("efficiencys " +efficiency);
        scoreEfficiency = Math.floor(scoreEfficiency);
        //console.log("Update Eff floor" +scoreEfficiency);
        temp_efficiency = scoreEfficiency;

        bestEfficiency = (scoreEfficiency > bestEfficiency) ? scoreEfficiency : bestEfficiency;
        //add efficiency
       

    }
}

Level.prototype.updateScoreGameOver = function() {
    // Update efficiency

    if (player_number_arrow_shoot < effeiciency_number_arrow_update) efficiency = temp_efficiency;
    this.fTxt_efficiency_gameOver.text = efficiency + "%";
    //console.log("Eff Game Over " +efficiency);
    localData.Efficiency = efficiency;
    //Update Score
    this.fTxt_best_Score_gameOver.text = bestScore;
    this.fTxt_Score_gameOver.text = score;
    localData.Score = score;
    //Update Best Head Shot
    this.fTxt_best_HeadShot_gameOver.text = bestHeadShot;
    this.fTxt_HeadShot_gameOver.text = headShot;
    localData.HeadShot = headShot;


}

Level.prototype.resetScore = function() {
    //Reset Score
    score = 0;
    this.f_grpTimeDuel.updateScoreSingleMode (score);
    //Reset efficiency
    efficiency = 0;
    player_arrow_count_hit_something =0;

    headShot = 0;

}

//Visible text score in scene game play
Level.prototype.visibleTextScoreGamePlay = function(visible) {

    //Score

 
 
     
    this.fDot.visible = false;
}

//Update Challenges follow time Game
Level.prototype.updateChallengeMode = function() {


    if (game.time.totalElapsedSeconds() >= difficult_raise_time) {
        difficult_raise_time += LEVEL_TIME;
        wall_current_level++;
        wall_current_level = (wall_current_level >= LEVEL_MAX) ? LEVEL_MAX : wall_current_level;
    }




    for (var i = 0; i < wall_current_level; i++) {
        var wall = wallGroup.getAt(i);
        wall.visible = true;
        wall.x = SCREEN_WIDTH / 2 - wall.width / 2;
        wall.y = 663 - (i * 35);
        game.physics.enable(wall, Phaser.Physics.ARCADE);
        wall.body.allowGravity = false;

    }
}

Level.prototype.wallMovement = function() {

    if (score >= SCORE_RAISE_DIFFICULT) {

        this.fWall_1.visible = true;
        this.fWall_1.x = SCREEN_WIDTH / 2;


        if (this.fWall_1.y <= WALL_LIMIT_TOP) {

            wall_change = 1;
        } else if (this.fWall_1.y >= WALL_LIMIT_BOTTOM) {
            wall_change = -1;

        }

        //move
        this.fWall_1.y += WALL_SPEED * wall_change;
        //Add physic wall

        wallGroup.getAt(0).body.allowGravity = false;
        wallGroup.getAt(0).body.enable = true;

        //Update Arrow move follow Ground
        for (var i = 0; i < arrowPlayerPool.length; i++) {
            //Arrow Player
            if (player_arrow_collisions[i] === COLLISION.GROUND) {
                arrowPlayerPool.getAt(i).y += WALL_SPEED * wall_change;
            }
            //Arrow Enemy
            if (enemy_arrow_collisions[i] === COLLISION.GROUND) {
                arrowEnemyPool.getAt(i).y += WALL_SPEED * wall_change;
            }
        }


    }

}

Level.prototype.sceneGameOver = function() {
	this.f_grp_Tutorial.visible = false;
    //Update Score Game
    //this.updateScoreGameOver();



    isMouseDrag = false;
    inputPointStart.x = OUT_SIDE_POSITION;
    inputPointStart.y = OUT_SIDE_POSITION;
    inputPointEnd.x = OUT_SIDE_POSITION;
    inputPointEnd.y = OUT_SIDE_POSITION;
    line.x = OUT_SIDE_POSITION;
    line.y = OUT_SIDE_POSITION;
    arrowObject.visible = false;


    //Hide All Arrow
    for (var i = 0; i < NUMBER_OF_ARROWS; i++) {
        arrowPlayerPool.getAt(i).visible = false;
        arrowEnemyPool.getAt(i).visible = false;
    }

    isUpdateDifficult = false;
    wall_current_level = 1;
    //Hide Wall
    for (var i = 0; i < wallGroup.length; i++) {
        wallGroup.getAt(i).x = OUT_SIDE_POSITION;
        wallGroup.getAt(i).y = OUT_SIDE_POSITION;
        wallGroup.getAt(i).visible = false;


    }
    wallGroup.getAt(0).body.enable = false;

    //Hide text score in gameplay scene
    this.visibleTextScoreGamePlay(false);

    //Hide Enemy when Player Death
    enemy_shoot.visible = false;
    enemy_idle.visible = false;
    enemy_health_bar.visible = false;
    this.enemy_kill = 0;


    //Reset setting game Mode when game Over
    this.enemy_shoot_time = 1.5;
    enemy_arrow_min_speed = 400;
    enemy_arrow_max_speed = 1000;
    enemy_idle_time = 1.3;
    enemy_rotation_speed = 0.015;
    this.point_height = 400;
    this.player_arrow_count_hit_something = 0;
    this.game.physics.arcade.gravity.y = this.GRAVITY_FORCE_EASY_MODE;
}

Level.prototype.sendMessage = function(message) {
    GlobalSetting.photonManager.onEventSendMessage(message);
}

//When change game mode change setting of game
Level.prototype.settingDifficult = function() {

    if (score < this.EASY_MODE) {
        //Enemy Easy
        //	console.log("Easy Mode");
        enemy_elapsed_shoot = game.time.totalElapsedSeconds() + this.enemy_shoot_time;
    } else {
        //Enemy HARD
        //console.log("Hard Mode");

        //RECDUCE TIME SHOOT ARROW
        enemy_elapsed_shoot = game.time.totalElapsedSeconds() + this.enemy_shoot_time / 3.5;
        //RAISE SPEED ARROW
        enemy_arrow_min_speed = 800;
        enemy_arrow_max_speed = 2000;
        //Recduce idle time
        enemy_idle_time = 0.1;
        //Raise rotation bow
        enemy_rotation_speed = 0.015 * 2;

        this.point_height = 200;
        //Rasie gravity of game
        this.game.physics.arcade.gravity.y = this.GRAVITY_FORCE_HARD_MODE;

        //console.log("GRAvity "+ this.game.physics.arcade.gravity.y );

    }
}

//State of Enemy
Level.prototype.stateEnemy = function() {
    //============= ENEMY STATE =======================
    if (this.playMode != PLAYMODE.SINGLE) return;

    if (enemyState === ENEMYSTATE.IDLE) {

        if (game.time.totalElapsedSeconds() >= enemy_elapsed_idle_time) {

            enemyState = ENEMYSTATE.ROTATION_SHOOT;
            enemy_angle = RndPosition(-0.3, 0.3);
            //Enemy AI
            arrowEnemy = getArrow(arrowEnemyPool, enemy_arrow_collisions, enemy_idle.x + 33
                , enemy_idle.y + 66, false); //61

            //	enemy_elapsed_shoot =  game.time.totalElapsedSeconds() + enemy_shoot_time ;

            //Raise difficult in game
            this.settingDifficult();

            this.enemy_target_rnd_y = 1.2;
            enemy_down_rnd_rotation = RndPosition(0.1, 0.3);
        }
        //		enemyHealth();



    } else if (enemyState === ENEMYSTATE.ROTATION_SHOOT) {
        enemy_shoot.visible = true;
        enemy_idle.visible = false;
        enemy_shoot.x = enemy_idle.x;
        enemy_shoot.y = enemy_idle.y;

        enemy_angle += (enemy_rotation_speed * enemy_angle_change);

        this.targetHeight = (player_idle.y - enemy_shoot.y) / this.enemy_target_rnd_y;

        this.fPoint_Player_Bottom.x = player_idle.x + 50;
        this.fPoint_Player_Bottom.y = player_idle.y + this.point_height;

        this.fPoint_Player_Top.x = player_idle.x + 50;
        this.fPoint_Player_Top.y = player_idle.y - this.point_height;

        //Update position of Player and Enemy 
        this.fPoint_Player.x = player_idle.x + 50;
        this.fPoint_Player.y = player_idle.y + this.targetHeight;
        this.fPoint_Enemy.x = enemy_shoot.x + 30;
        this.fPoint_Enemy.y = enemy_shoot.y + 100;


        var anglePlayer = this.game.physics.arcade.angleBetween(this.fPoint_Player, this.fPoint_Enemy);
        var anglePlayerTop = this.game.physics.arcade.angleBetween(this.fPoint_Player_Top, this.fPoint_Enemy);
        var anglePlayerBottom = this.game.physics.arcade.angleBetween(this.fPoint_Player_Bottom, this.fPoint_Enemy);
        if (this.enemy_arrow_random_count >= this.enemy_arrow_number_miss) {
            anglePlayerBottom = -MAX_ROTATION;
            anglePlayerTop = MAX_ROTATION;
        }


        if (enemy_angle >= anglePlayerTop + enemy_down_rnd_rotation) {
            enemy_angle_change = -1;
        }

        if (enemy_angle <= anglePlayerBottom - enemy_down_rnd_rotation) {
            enemy_angle_change = 1;
        }


        enemy_left_shoot.rotation = enemy_angle / 1.1;
        enemy_bow.rotation = enemy_angle / 1.5;

        if (arrowEnemy != null || arrowEnemy != undefined) {

            arrowEnemy.rotation = enemy_angle / 2;

        }

        if (this.enemy_arrow_random_count >= this.enemy_arrow_number_miss) {
            //Enemy will shoot random 3 arrow and before shoot correct 
            if (enemy_angle >= anglePlayer - 0.1 && enemy_angle <= anglePlayer + 0.1) {
                if (game.time.totalElapsedSeconds() >= enemy_elapsed_shoot) {
                    enemyState = ENEMYSTATE.SHOOT;
                    arrowEnemy.rotation = enemy_bow.rotation;
                    arrowEnemy.body.allowGravity = true;

                    //Movement of arrow
                    arrowEnemy.body.velocity.x = Math.cos(arrowEnemy.rotation) * -1000;
                    arrowEnemy.body.velocity.y = Math.sin(arrowEnemy.rotation) * -1000;

                    this.enemy_arrow_random_count = 0;

                }
            }

        } else {

            //Enemy will shoot random 3 arrow and before shoot correct 

            if (game.time.totalElapsedSeconds() >= enemy_elapsed_shoot) {

                //Play SE
                this.game.sound.play("sfx_arrow_fly_enemy", GlobalSetting.SEVolume / 2);

                //console.log("Shoot");
                this.enemy_arrow_random_count++;
                enemyState = ENEMYSTATE.SHOOT;
                enemy_arrow_speed = RndPosition(enemy_arrow_min_speed, enemy_arrow_max_speed);
                arrowEnemy.rotation = enemy_bow.rotation;

                arrowEnemy.body.allowGravity = true;

                //Movement of arrow
                arrowEnemy.body.velocity.x = Math.cos(arrowEnemy.rotation) * -enemy_arrow_speed;
                arrowEnemy.body.velocity.y = Math.sin(arrowEnemy.rotation) * -enemy_arrow_speed;
            }
        }



    } else if (enemyState === ENEMYSTATE.SHOOT) {
        enemy_idle.visible = true;
        enemy_shoot.visible = false;


        arrowEnemyPool.forEachAlive(function(arrow) {
            arrow.rotation = Math.atan2(-arrow.body.velocity.y, -arrow.body.velocity.x);
        }, this);


        //KIll arrow when arrow out bounds
        if (Math.abs(arrowEnemy.x) <= 0 - arrowEnemy.width ||
            ((arrowEnemy.y >= SCREEN_HEIGHT + arrowEnemy.height ||
                arrowEnemy.y <= 0 - arrowEnemy.height))) {
            enemy_elapsed_idle_time = game.time.totalElapsedSeconds() + enemy_idle_time;
            enemyState = ENEMYSTATE.IDLE;
            arrowEnemy.body.allowGravity = false;
            arrowEnemy.visible = false;
        }
    } else if (enemyState === ENEMYSTATE.SETTING_EFFECT_VAR) {

        this.updateScore(false);
        this.enemy_kill++;
        enemy_reload_time = game.time.totalElapsedSeconds() + enemy_reload_show_time;
        enemy_fade_time = game.time.totalElapsedSeconds() + enemy_duration_fade_time;
        enemy_fade_total_time = game.time.totalElapsedSeconds() + (enemy_duration_fade_time * FADE_EFFECT_CHARACTER_COUNT);
        enemy_head_Collider.body.enable = false;
        enemy_body_Collider.body.enable = false;
        enemyState = ENEMYSTATE.FADE_DEATH;
    } else if (enemyState === ENEMYSTATE.FADE_DEATH) {
        if (arrowEnemy != null || arrowEnemy != undefined)
            arrowEnemy.visible = false;

        enemy_idle.visible = false;
        enemy_shoot.visible = false;
        // enemyState = ENEMYSTATE.EFFECT_DEATH;

        if (game.time.totalElapsedSeconds() >= enemy_fade_time) {
            enemy_sprite_death.visible = !enemy_sprite_death.visible;
            enemy_fade_time = game.time.totalElapsedSeconds() + enemy_duration_fade_time;

        }

        if (game.time.totalElapsedSeconds() >= enemy_fade_total_time) {
            enemyState = ENEMYSTATE.EFFECT_DEATH;
        }

        // console.log("enemyState FADE_DEATH " );

    } else if (enemyState === ENEMYSTATE.EFFECT_DEATH) {
        //console.log("enemyState" +enemyState);
        enemy_sprite_death.visible = true;
        enemy_sprite_death.y += CHARACTER_DROP_SPEED;

        for (var i = 0; i < arrowPlayerPool.length; i++) {
            if (player_arrow_collisions[i] === COLLISION.BODY ||
                player_arrow_collisions[i] === COLLISION.HEAD) {
                arrowPlayerPool.getAt(i).y += CHARACTER_DROP_SPEED;
            }
        }

        if (enemy_sprite_death.y > SCREEN_HEIGHT + enemy_sprite_death.height) {
            enemyState = ENEMYSTATE.RELOAD;

        }
        // console.log("enemyState EFFECT_DEATH " + enemy_sprite_death.y );

    } else if (enemyState === ENEMYSTATE.RELOAD) {
        if (game.time.totalElapsedSeconds() >= enemy_reload_time) {
            this.enemyReload();
        }
    } else if (enemyState === ENEMYSTATE.STAND) {

        //enemy_shoot.visible = false;
        //enemy_idle.visible = false;
        //enemy_health_bar.visible =false;
    }
}

function registerCollision() {

    //Add Physic Collision Arrow Player to Enemy
    if (arrowPlayer != undefined) {
        game.physics.arcade.overlap(arrowPlayer, enemy_head_Collider, onTriggerEnemyHead, null, this);
        game.physics.arcade.overlap(arrowPlayer, enemy_body_Collider, onTriggerEnemyBody, null, this);
        game.physics.arcade.overlap(arrowPlayer, enemy_health_bar, onTriggerPlayerHealthBar, null, this);
        game.physics.arcade.overlap(arrowPlayer, wallGroup, onTriggerPlayerGround, null, this);

    }
    if (arrowEnemy != undefined) {
        game.physics.arcade.overlap(arrowEnemy, player_head_Collider, onTriggerPlayerHead, null, this);
        game.physics.arcade.overlap(arrowEnemy, player_body_Collider, onTriggerPlayerBody, null, this);
        game.physics.arcade.overlap(arrowEnemy, player_health_bar, onTriggerEnemyHealthBar, null, this);
        game.physics.arcade.overlap(arrowEnemy, wallGroup, onTriggerEnemyGround, null, this);
    }
}

Level.prototype.healthBarPosition = function() {
    if (this.playMode === PLAYMODE.SINGLE) {
    	var temSprite = (player_shoot.visible) ? player_shoot :player_idle;
    	//	console.log("player_idle.y " +player_idle.y);
        player_health_bar.position.setTo(player_idle.x - 7,player_idle.y + 119);
       // player_health_bar.x = player_shoot.x - 7; //14
        //player_health_bar.y = player_shoot.y + 119; //119
    } else {

        //console.log("");
        player_health_bar.x = player_idle.x - 7; //14
        player_health_bar.y = player_idle.y + 119; //119
        
       

       


        enemy_health_bar.x = enemy_idle.x - 100;
        enemy_health_bar.y = enemy_idle.y + 117;


        this.fTxt_player_02.x = enemy_idle.x - 50;
        this.fTxt_player_02.y = enemy_idle.y +this.f_grp_characterSkin.currentSettingClient.position_Y_name;
    }
    
    this.fTxt_player_01.x = player_idle.x + 50 ;
    this.fTxt_player_01.y = player_idle.y +this.f_grp_characterSkin.currentSettingMaster.position_Y_name;

}


Level.prototype.settingCharacter = function() {
    //Set Player Collider
    player_body_Collider.body.x = player_idle.x + this.f_grp_characterSkin.currentSettingMaster.position_X_Body_Collider;
    player_body_Collider.body.y = player_idle.y +  this.f_grp_characterSkin.currentSettingMaster.position_Y_Body_Collider;;

    player_head_Collider.body.x = player_idle.x + this.f_grp_characterSkin.currentSettingMaster.position_X_Head_Collider;
    player_head_Collider.body.y = player_idle.y + this.f_grp_characterSkin.currentSettingMaster.position_Y_Head_Collider;
    if (this.playMode === PLAYMODE.SINGLE) {
        //Set Player Collider
        enemy_body_Collider.body.x = enemy_idle.x + 19;
        enemy_body_Collider.body.y = enemy_idle.y + 49;

        enemy_head_Collider.body.x = enemy_idle.x + 7;
        enemy_head_Collider.body.y = enemy_idle.y + 1;
    } else {

        //Set Other Player Collider
        enemy_body_Collider.body.x = enemy_idle.x + this.f_grp_characterSkin.currentSettingClient.position_X_Body_Collider;
        enemy_body_Collider.body.y = enemy_idle.y + this.f_grp_characterSkin.currentSettingClient.position_Y_Body_Collider;

        enemy_head_Collider.body.x = enemy_idle.x + this.f_grp_characterSkin.currentSettingClient.position_X_Head_Collider; //-75
        enemy_head_Collider.body.y = enemy_idle.y + this.f_grp_characterSkin.currentSettingClient.position_Y_Head_Collider; //10
    }

}

function getArrow(arrowPool, arrowCollision, positionX, positionY, player) {
    var arrow;
    console.log("arrowPool.length " + arrowPool.length);
    for (var i = 0; i < arrowPool.length; i++) {
        console.log("arrowPool.getAt("+i+").visible " + arrowPool.getAt(i));
        //	console.log(" arrowCollision ["+i+"]  " +  arrowCollision [i]);
        if (!arrowPool.getAt(i).visible && arrowCollision[i] === COLLISION.NONE) {

            arrow = arrowPool.getAt(i);

            if (player) {
                arrowPlayerCurrentIndex = i;
                arrowPlayerVisible[i] = false;
            } else
                arrowEnemyCurrentIndex = i;
            if (level.playMode != PLAYMODE.SINGLE)
                arrowEnemyVisible[i] = false;

            break;
        }
    }


    arrow.animations.play('full');
    arrow.body.enable = true;
    arrow.body.moves = true;
    arrow.checkWorldBounds = true;
    arrow.body.allowGravity = false;
    // Set the arrow position to the bow position 
    arrow.reset(positionX, positionY);
    arrow.visible = true;
    return arrow;
};



function shootArrow(arrow, arrowSpeed, arrowRotation) {
    if (arrow.body === null || arrow.body === undefined) return;
    //Active gravity and rotation of arrow

    arrow.body.allowGravity = true;
    arrow.rotation = arrowRotation;
    //Clamp Distance line
    if (userType === USERTYPE.MASTER) {
        arrowSpeed = (arrowSpeed <= LIMIT_SPEED_ARROW) ? LIMIT_SPEED_ARROW : arrowSpeed;
    } else {
        arrowSpeed = (arrowSpeed <= -LIMIT_SPEED_ARROW) ? arrowSpeed : -LIMIT_SPEED_ARROW;
    }

    //Movement of arrow
    arrow.body.velocity.x = Math.cos(arrow.rotation) * arrowSpeed * ARROW_ACCEL;
    arrow.body.velocity.y = Math.sin(arrow.rotation) * arrowSpeed * ARROW_ACCEL;


}


function shootArrowOther(arrow, arrowSpeed, arrowRotation) {
    if (arrow.body === null || arrow.body === undefined) return;
    //Active gravity and rotation of arrow

    arrow.body.allowGravity = true;
    arrow.rotation = arrowRotation;
    //Clamp Distance line
    if (userType === USERTYPE.CLIENT) {
        arrowSpeed = (arrowSpeed <= LIMIT_SPEED_ARROW) ? LIMIT_SPEED_ARROW : arrowSpeed;
    } else {
        arrowSpeed = (arrowSpeed <= -LIMIT_SPEED_ARROW) ? arrowSpeed : -LIMIT_SPEED_ARROW;
    }

    //Movement of arrow
    arrow.body.velocity.x = Math.cos(arrow.rotation) * arrowSpeed * ARROW_ACCEL;
    arrow.body.velocity.y = Math.sin(arrow.rotation) * arrowSpeed * ARROW_ACCEL;


}

//Random Position
function RndPosition(minValue, maxValue) {
    return game.rnd.realInRange(minValue, maxValue);
}

function RndInteger(minValue, maxValue) {
    return game.rnd.integerInRange(minValue, maxValue);
}

function enemyHealth() {
    if (checkHealth(enemy_health_bar, enemy_current_health)) {

        enemyState = ENEMYSTATE.SETTING_EFFECT_VAR;
        if (enemy_idle.visible) enemy_sprite_death = enemy_idle;
        if (enemy_shoot.visible) enemy_sprite_death = enemy_shoot;

    }
}

Level.prototype.enemyHealthDuel = function() {
    if (checkHealth(enemy_health_bar, enemy_current_health)) {

        //Player Death
        if (enemy_idle.visible) player_sprite_death = enemy_idle;
        if (enemy_shoot.visible) player_sprite_death = enemy_shoot;

        currentScene = SCENES.SETTING_FADE_PLAYER;




        enemy_idle.visible = false;
        enemy_shoot.visible = false;
        enemy_head_Collider.body.enable = false;
        enemy_body_Collider.body.enable = false;
        //arrowPlayerBodyIndex = 0;
        arrowEnemyObject.visible = false;




    }
}
var other_player_sprite_death;

function playerHealth() {
    if (checkHealth(player_health_bar, player_current_health)) {

        //Player Death
        if (player_idle.visible) player_sprite_death = player_idle;
        if (player_shoot.visible) player_sprite_death = player_shoot;

        if (userType === USERTYPE.MASTER) {
            currentScene = SCENES.SETTING_FADE_PLAYER;
        }

        if (playMode != PLAYMODE.SINGLE) {

            if (player_idle.visible) {
                other_player_sprite_death = player_idle;
            }
            if (player_shoot.visible) {
                other_player_sprite_death = player_shoot;
            }
        }


        if (level.playMode === PLAYMODE.SINGLE) {
            player_idle.visible = false;
            player_shoot.visible = false;
        }


        player_head_Collider.body.enable = false;
        player_body_Collider.body.enable = false;
        arrowPlayerBodyIndex = 0;
        arrowObject.visible = false;


        enemyState = ENEMYSTATE.STAND;

    }
}
//=====================endregion================================================================



//=====================#region Collision function================================================================


Level.prototype.checkHealthDuelMode = function(damage, headShot) {
	
	console.log("Take Damage ");
    if (userType === USERTYPE.MASTER) {
        //Player
    	 player_current_health -= damage;
    	 isPlayerHeadShoot = headShot;
         console.log("isPlayerHeadShoot " + isPlayerHeadShoot);
         playerHealth();
    } else {
        enemy_current_health -= damage;
        isEnemyHeadShoot = headShot;
        console.log("isEnemyHeadShoot " + isEnemyHeadShoot);
        this.enemyHealthDuel();
    }


}


function onTriggerEnemyHead(arrow) {
    this.game.sound.play("sfx_hit", GlobalSetting.SEVolume);
   if(level.playMode === PLAYMODE.SINGLE){
        enemy_current_health -= MAX_HEALTH;
      
   }
   else {
        if (userType === USERTYPE.MASTER) {
            options = {};
            options.receivers = Photon.LoadBalancing.Constants.ReceiverGroup.Others;
            var damage = {};
            damage.takeDamage = MAX_HEALTH;
            damage.isHeadShoot = true;
            GlobalSetting.photonManager.onRaiseEvent(2, damage, options);
        }
    }



   isEnemyHeadShoot = true;

   if (playMode === PLAYMODE.SINGLE) {

        enemyHealth();
    }


    if (findArrow(arrowPlayerPool, arrow) != null) {
        playerHitGround(arrow);
    }


    
    //Update  head shot score
    efficiency++;
    headShot++;
    bestHeadShot = (headShot > bestHeadShot) ? headShot : bestHeadShot;
    player_arrow_collisions[arrowPlayerCurrentIndex] = COLLISION.HEAD;

}

function onTriggerEnemyBody(arrow) {
    this.game.sound.play("sfx_hit", GlobalSetting.SEVolume);
    


    if (level.playMode === PLAYMODE.SINGLE) {
        
        enemy_current_health -= 1;
        enemyHealth();
    } else {
        if (userType === USERTYPE.MASTER) {
            options = {};
            options.receivers = Photon.LoadBalancing.Constants.ReceiverGroup.Others;
            var damage = {};
            damage.takeDamage = 1;
            damage.isHeadShoot = false;
            GlobalSetting.photonManager.onRaiseEvent(2, damage, options);
        }
    }


    efficiency++;
    if (findArrow(arrowPlayerPool, arrow) != null) {
        playerHitGround(arrow);
    }

    player_arrow_collisions[arrowPlayerCurrentIndex] = COLLISION.BODY;

}


function onTriggerPlayerHealthBar(arrow) {
    //console.log("Hit Health Bar");

    if (findArrow(arrowPlayerPool, arrow) != null) {
        playerHitGround(arrow);
    }

    player_arrow_collisions[arrowPlayerCurrentIndex] = COLLISION.HEATH_BAR;
   
}




function onTriggerPlayerGround(arrow) {

    if (findArrow(arrowPlayerPool, arrow) != null) {
        // console.log("Hit Ground");
        playerHitGround(arrow);
  
    }

}



function playerHitGround(arrow) {
    //console.log(" Collision Player Arrow");
    arrow.body.enable = false;
    arrow.body.moves = false;
    arrow.animations.play('hit', 60);
    if (userType === USERTYPE.MASTER)
        level.isShootArrow = false;
    arrowPlayerVisible[arrowPlayerCurrentIndex] = true;
    arrowPlayerElapsedTime[arrowPlayerCurrentIndex] = game.time.totalElapsedSeconds() + arrowPlayerDuration;
    player_arrow_collisions[arrowPlayerCurrentIndex] = COLLISION.GROUND;
    level.other_arrow_count_shoot++;

}

function onTriggerPlayerBody(arrow) {

    this.game.sound.play("sfx_hit", GlobalSetting.SEVolume);
 
    if (level.playMode === PLAYMODE.SINGLE) {
    	  player_current_health -= 1;
    	    playerHealth();
    } else {
        if (userType === USERTYPE.CLIENT) {
            options = {};
            options.receivers = Photon.LoadBalancing.Constants.ReceiverGroup.Others;
            var damage = {};
            damage.takeDamage = 1;
            damage.isHeadShoot = false;
            GlobalSetting.photonManager.onRaiseEvent(2, damage, options);
        }
    }
  

  

    arrowsPlayerBody[arrowPlayerBodyIndex] = arrow;
    arrowPlayerBodyIndex++;
    onTriggerEnemyGround(arrow);
    enemy_arrow_collisions[arrowEnemyCurrentIndex] = COLLISION.BODY;
}

function onTriggerPlayerHead(arrow) {

    if (level.playMode === PLAYMODE.SINGLE) {
        player_current_health -= MAX_HEALTH;
        playerHealth();
       
    } else {
        if (userType === USERTYPE.CLIENT) {
            options = {};
            options.receivers = Photon.LoadBalancing.Constants.ReceiverGroup.Others;
            var damage = {};
            damage.takeDamage = MAX_HEALTH;
            damage.isHeadShoot = true;
            GlobalSetting.photonManager.onRaiseEvent(2, damage, options);
        }
    }
    
   
	
    isPlayerHeadShoot = true;


    
    arrowPlayerHeadShoot = arrow;
    onTriggerEnemyGround(arrow);
    enemy_arrow_collisions[arrowEnemyCurrentIndex] = COLLISION.HEAD;


}

function onTriggerEnemyHealthBar(arrow) {
    onTriggerEnemyGround(arrow);
    enemy_arrow_collisions[arrowEnemyCurrentIndex] = COLLISION.HEATH_BAR;
}


function onTriggerEnemyGround(arrow) {

    if (findArrow(arrowEnemyPool, arrow) != null) {
        enemyHitGround(arrow);
    }
}

function enemyHitGround(arrow) {
    arrow.body.moves = false;
    arrow.body.enable = false;
    arrow.animations.play('hit', 60);
    arrowEnemyVisible[arrowEnemyCurrentIndex] = true;
    arrowEnemyElapsedTime[arrowEnemyCurrentIndex] = game.time.totalElapsedSeconds() + arrowEnemyDuration;
    enemy_elapsed_idle_time = game.time.totalElapsedSeconds() + enemy_idle_time;
    enemy_arrow_collisions[arrowEnemyCurrentIndex] = COLLISION.GROUND;
    //When player death enemy stop Shoot
    if (userType === USERTYPE.CLIENT) {
        level.isShootArrow = false;
    }
    if (!checkHealth(player_health_bar, player_current_health)) {
        enemyState = ENEMYSTATE.IDLE;

    }
}




function checkHealth(sprite, health) {
    if (health === 2) {
        sprite.animations.play('full');
        return false;
    }
    if (health === 1) {
        sprite.animations.play('half');
        return false;
    }
    if (health <= 0) {
        sprite.animations.play('death');
        return true;
    }
    return false;
}

function findArrow(arrowPool, arrow) {
    for (var i = 0; i < arrowPool.length; i++) {
        if (arrowPool.getAt(i) === arrow)
            return arrowPool.getAt(i);
    }
    return null;
}



function gameHeight() {
    return game.height;
}

//============ region Playfab function ========================
Level.prototype.saveData = function() {

    //Update Data
	localData.HeadShot = headShot;
	localData.Score = score;
    localData.Efficiency = efficiency;
    localData.BestEfficiency = bestEfficiency;
    localData.BestHeadShot = bestHeadShot;
    localData.BestScore = bestScore;
    localData.FacebookID = FBInstant.player.getID();
    
   

    
    //console.log("JSON Save Data " +JSON.stringify(localData));
    
   
    game.PlayFab.ClientApi.UpdateUserData({
        "Data": JSON.stringify(localData),
    });
   
    
    
    
    
   
    
}




Level.prototype.fadeScale = function(sprite, minScale, maxScale, scale, scaleChange) {
    var valueScale = sprite.scale.x;
    if (valueScale >= maxScale) {
        scaleChange = -1;
    } else if (valueScale <= minScale) {
        scaleChange = 1;
    }
    valueScale += scale * scaleChange;
    sprite.scale.setTo(valueScale);
    return scaleChange;
}

Level.prototype.fadeScaleMax = function(sprite, minScale, maxScale, scale) {
    var valueScale = sprite.scale.x;

    var scaleChange=1;
    if (valueScale >= maxScale) {
        sprite.scale.setTo(minScale);
        valueScale  = minScale;
    } 
    
    valueScale += scale * scaleChange;
    sprite.scale.setTo(valueScale);
   
}


Level.prototype.fadeAlphaMax = function(sprite, minAlpha, maxAlpha, alpha) {
    var valueAlpha = sprite.alpha;

    var alphaChange=1;
    if (valueAlpha >= maxAlpha) {
        sprite.alpha = minAlpha;
        valueAlpha  = minAlpha;
    } 
    valueAlpha += alpha * alphaChange;
    sprite.alpha = valueAlpha;
   
}

Level.prototype.fadeAlphaMin = function(sprite, minAlpha, maxAlpha, alpha) {
    var valueAlpha = sprite.alpha;

    var alphaChange=-1;
    if (valueAlpha <= minAlpha) {
        sprite.alpha = maxAlpha;
        valueAlpha  = maxAlpha;
    } 
    valueAlpha += alpha * alphaChange;
    sprite.alpha = valueAlpha;
   
}